Grammar:

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statement
Rule 3     statements -> statements statement
Rule 4     statement -> ;
Rule 5     statement -> { statements }
Rule 6     statement -> FOR ID = range_expr statement
Rule 7     statement -> WHILE ( condition ) statement
Rule 8     statement -> IF ( condition ) statement ELSE statement  [precedence=nonassoc, level=2]
Rule 9     statement -> IF ( condition ) statement  [precedence=nonassoc, level=1]
Rule 10    statement -> PRINT elements ;
Rule 11    statement -> RETURN expr ;
Rule 12    statement -> CONTINUE ;
Rule 13    statement -> BREAK ;
Rule 14    statement -> assignment ;
Rule 15    lvalue -> _index
Rule 16    lvalue -> ID
Rule 17    assignment -> lvalue DIVASSIGN expr
Rule 18    assignment -> lvalue MULASSIGN expr
Rule 19    assignment -> lvalue SUBASSIGN expr
Rule 20    assignment -> lvalue ADDASSIGN expr
Rule 21    assignment -> lvalue = expr
Rule 22    condition -> expr GE expr  [precedence=nonassoc, level=4]
Rule 23    condition -> expr GT expr  [precedence=nonassoc, level=4]
Rule 24    condition -> expr LE expr  [precedence=nonassoc, level=4]
Rule 25    condition -> expr LT expr  [precedence=nonassoc, level=4]
Rule 26    condition -> expr NE expr  [precedence=nonassoc, level=4]
Rule 27    condition -> expr EQ expr  [precedence=nonassoc, level=4]
Rule 28    expr -> STRING
Rule 29    expr -> FLOATNUM
Rule 30    expr -> INTNUM
Rule 31    expr -> ( expr )
Rule 32    expr -> [ rows ]
Rule 33    expr -> ZEROS ( idx_list )
Rule 34    expr -> EYE ( idx_list )
Rule 35    expr -> ONES ( idx_list )
Rule 36    expr -> _index
Rule 37    expr -> ID  [precedence=left, level=9]
Rule 38    expr -> expr '  [precedence=right, level=8]
Rule 39    expr -> MINUS expr  [precedence=right, level=7]
Rule 40    expr -> expr DOTDIV expr  [precedence=left, level=6]
Rule 41    expr -> expr DOTMUL expr  [precedence=left, level=6]
Rule 42    expr -> expr DIVIDE expr  [precedence=left, level=6]
Rule 43    expr -> expr TIMES expr  [precedence=left, level=6]
Rule 44    expr -> expr DOTSUB expr  [precedence=left, level=5]
Rule 45    expr -> expr DOTADD expr  [precedence=left, level=5]
Rule 46    expr -> expr MINUS expr  [precedence=left, level=5]
Rule 47    expr -> expr PLUS expr  [precedence=left, level=5]
Rule 48    _index -> ID [ idx_list ]
Rule 49    idx_list -> idx_list , INTNUM
Rule 50    idx_list -> INTNUM
Rule 51    rows -> rows ; elements
Rule 52    rows -> elements
Rule 53    elements -> elements , expr
Rule 54    elements -> expr
Rule 55    range_expr -> expr : expr  [precedence=nonassoc, level=3]
Rule 56    range_expr -> expr : expr : expr  [precedence=nonassoc, level=3]

Terminals, with rules where they appear:

'                    : 38
(                    : 7 8 9 31 33 34 35
)                    : 7 8 9 31 33 34 35
,                    : 49 53
:                    : 55 56 56
;                    : 4 10 11 12 13 14 51
=                    : 6 21
ADDASSIGN            : 20
BREAK                : 13
CONTINUE             : 12
DIVASSIGN            : 17
DIVIDE               : 42
DOTADD               : 45
DOTDIV               : 40
DOTMUL               : 41
DOTSUB               : 44
ELSE                 : 8
EQ                   : 27
EYE                  : 34
FLOATNUM             : 29
FOR                  : 6
GE                   : 22
GT                   : 23
ID                   : 6 16 37 48
IF                   : 8 9
INTNUM               : 30 49 50
LE                   : 24
LT                   : 25
MINUS                : 39 46
MULASSIGN            : 18
NE                   : 26
ONES                 : 35
PLUS                 : 47
PRINT                : 10
RETURN               : 11
STRING               : 28
SUBASSIGN            : 19
TIMES                : 43
WHILE                : 7
ZEROS                : 33
[                    : 32 48
]                    : 32 48
error                : 
{                    : 5
}                    : 5

Nonterminals, with rules where they appear:

_index               : 15 36
assignment           : 14
condition            : 7 8 9
elements             : 10 51 52 53
expr                 : 11 17 18 19 20 21 22 22 23 23 24 24 25 25 26 26 27 27 31 38 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 53 54 55 55 56 56 56
idx_list             : 33 34 35 48 49
lvalue               : 17 18 19 20 21
program              : 0
range_expr           : 6
rows                 : 32 51
statement            : 2 3 6 7 8 8 9
statements           : 1 3 5


state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . ;
    (5) statement -> . { statements }
    (6) statement -> . FOR ID = range_expr statement
    (7) statement -> . WHILE ( condition ) statement
    (8) statement -> . IF ( condition ) statement ELSE statement
    (9) statement -> . IF ( condition ) statement
    (10) statement -> . PRINT elements ;
    (11) statement -> . RETURN expr ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . BREAK ;
    (14) statement -> . assignment ;
    (17) assignment -> . lvalue DIVASSIGN expr
    (18) assignment -> . lvalue MULASSIGN expr
    (19) assignment -> . lvalue SUBASSIGN expr
    (20) assignment -> . lvalue ADDASSIGN expr
    (21) assignment -> . lvalue = expr
    (15) lvalue -> . _index
    (16) lvalue -> . ID
    (48) _index -> . ID [ idx_list ]
    ;               shift and go to state 4
    {               shift and go to state 5
    FOR             shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 7

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    assignment                     shift and go to state 14
    lvalue                         shift and go to state 15
    _index                         shift and go to state 16

state 1

    (0) S' -> program .


state 2

    (1) program -> statements .
    (3) statements -> statements . statement
    (4) statement -> . ;
    (5) statement -> . { statements }
    (6) statement -> . FOR ID = range_expr statement
    (7) statement -> . WHILE ( condition ) statement
    (8) statement -> . IF ( condition ) statement ELSE statement
    (9) statement -> . IF ( condition ) statement
    (10) statement -> . PRINT elements ;
    (11) statement -> . RETURN expr ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . BREAK ;
    (14) statement -> . assignment ;
    (17) assignment -> . lvalue DIVASSIGN expr
    (18) assignment -> . lvalue MULASSIGN expr
    (19) assignment -> . lvalue SUBASSIGN expr
    (20) assignment -> . lvalue ADDASSIGN expr
    (21) assignment -> . lvalue = expr
    (15) lvalue -> . _index
    (16) lvalue -> . ID
    (48) _index -> . ID [ idx_list ]
    $end            reduce using rule 1 (program -> statements .)
    ;               shift and go to state 4
    {               shift and go to state 5
    FOR             shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 7

    statement                      shift and go to state 17
    assignment                     shift and go to state 14
    lvalue                         shift and go to state 15
    _index                         shift and go to state 16

state 3

    (2) statements -> statement .
    ;               reduce using rule 2 (statements -> statement .)
    {               reduce using rule 2 (statements -> statement .)
    FOR             reduce using rule 2 (statements -> statement .)
    WHILE           reduce using rule 2 (statements -> statement .)
    IF              reduce using rule 2 (statements -> statement .)
    PRINT           reduce using rule 2 (statements -> statement .)
    RETURN          reduce using rule 2 (statements -> statement .)
    CONTINUE        reduce using rule 2 (statements -> statement .)
    BREAK           reduce using rule 2 (statements -> statement .)
    ID              reduce using rule 2 (statements -> statement .)
    $end            reduce using rule 2 (statements -> statement .)
    }               reduce using rule 2 (statements -> statement .)


state 4

    (4) statement -> ; .
    ;               reduce using rule 4 (statement -> ; .)
    {               reduce using rule 4 (statement -> ; .)
    FOR             reduce using rule 4 (statement -> ; .)
    WHILE           reduce using rule 4 (statement -> ; .)
    IF              reduce using rule 4 (statement -> ; .)
    PRINT           reduce using rule 4 (statement -> ; .)
    RETURN          reduce using rule 4 (statement -> ; .)
    CONTINUE        reduce using rule 4 (statement -> ; .)
    BREAK           reduce using rule 4 (statement -> ; .)
    ID              reduce using rule 4 (statement -> ; .)
    $end            reduce using rule 4 (statement -> ; .)
    }               reduce using rule 4 (statement -> ; .)
    ELSE            reduce using rule 4 (statement -> ; .)


state 5

    (5) statement -> { . statements }
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . ;
    (5) statement -> . { statements }
    (6) statement -> . FOR ID = range_expr statement
    (7) statement -> . WHILE ( condition ) statement
    (8) statement -> . IF ( condition ) statement ELSE statement
    (9) statement -> . IF ( condition ) statement
    (10) statement -> . PRINT elements ;
    (11) statement -> . RETURN expr ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . BREAK ;
    (14) statement -> . assignment ;
    (17) assignment -> . lvalue DIVASSIGN expr
    (18) assignment -> . lvalue MULASSIGN expr
    (19) assignment -> . lvalue SUBASSIGN expr
    (20) assignment -> . lvalue ADDASSIGN expr
    (21) assignment -> . lvalue = expr
    (15) lvalue -> . _index
    (16) lvalue -> . ID
    (48) _index -> . ID [ idx_list ]
    ;               shift and go to state 4
    {               shift and go to state 5
    FOR             shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 7

    statements                     shift and go to state 18
    statement                      shift and go to state 3
    assignment                     shift and go to state 14
    lvalue                         shift and go to state 15
    _index                         shift and go to state 16

state 6

    (6) statement -> FOR . ID = range_expr statement
    ID              shift and go to state 19


state 7

    (16) lvalue -> ID .
    (48) _index -> ID . [ idx_list ]
    DIVASSIGN       reduce using rule 16 (lvalue -> ID .)
    MULASSIGN       reduce using rule 16 (lvalue -> ID .)
    SUBASSIGN       reduce using rule 16 (lvalue -> ID .)
    ADDASSIGN       reduce using rule 16 (lvalue -> ID .)
    =               reduce using rule 16 (lvalue -> ID .)
    [               shift and go to state 20


state 8

    (7) statement -> WHILE . ( condition ) statement
    (               shift and go to state 21


state 9

    (8) statement -> IF . ( condition ) statement ELSE statement
    (9) statement -> IF . ( condition ) statement
    (               shift and go to state 22


state 10

    (10) statement -> PRINT . elements ;
    (53) elements -> . elements , expr
    (54) elements -> . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    elements                       shift and go to state 23
    expr                           shift and go to state 24
    _index                         shift and go to state 33

state 11

    (11) statement -> RETURN . expr ;
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 36
    _index                         shift and go to state 33

state 12

    (12) statement -> CONTINUE . ;
    ;               shift and go to state 37


state 13

    (13) statement -> BREAK . ;
    ;               shift and go to state 38


state 14

    (14) statement -> assignment . ;
    ;               shift and go to state 39


state 15

    (17) assignment -> lvalue . DIVASSIGN expr
    (18) assignment -> lvalue . MULASSIGN expr
    (19) assignment -> lvalue . SUBASSIGN expr
    (20) assignment -> lvalue . ADDASSIGN expr
    (21) assignment -> lvalue . = expr
    DIVASSIGN       shift and go to state 40
    MULASSIGN       shift and go to state 41
    SUBASSIGN       shift and go to state 42
    ADDASSIGN       shift and go to state 43
    =               shift and go to state 44


state 16

    (15) lvalue -> _index .
    DIVASSIGN       reduce using rule 15 (lvalue -> _index .)
    MULASSIGN       reduce using rule 15 (lvalue -> _index .)
    SUBASSIGN       reduce using rule 15 (lvalue -> _index .)
    ADDASSIGN       reduce using rule 15 (lvalue -> _index .)
    =               reduce using rule 15 (lvalue -> _index .)


state 17

    (3) statements -> statements statement .
    ;               reduce using rule 3 (statements -> statements statement .)
    {               reduce using rule 3 (statements -> statements statement .)
    FOR             reduce using rule 3 (statements -> statements statement .)
    WHILE           reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    PRINT           reduce using rule 3 (statements -> statements statement .)
    RETURN          reduce using rule 3 (statements -> statements statement .)
    CONTINUE        reduce using rule 3 (statements -> statements statement .)
    BREAK           reduce using rule 3 (statements -> statements statement .)
    ID              reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    }               reduce using rule 3 (statements -> statements statement .)


state 18

    (5) statement -> { statements . }
    (3) statements -> statements . statement
    (4) statement -> . ;
    (5) statement -> . { statements }
    (6) statement -> . FOR ID = range_expr statement
    (7) statement -> . WHILE ( condition ) statement
    (8) statement -> . IF ( condition ) statement ELSE statement
    (9) statement -> . IF ( condition ) statement
    (10) statement -> . PRINT elements ;
    (11) statement -> . RETURN expr ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . BREAK ;
    (14) statement -> . assignment ;
    (17) assignment -> . lvalue DIVASSIGN expr
    (18) assignment -> . lvalue MULASSIGN expr
    (19) assignment -> . lvalue SUBASSIGN expr
    (20) assignment -> . lvalue ADDASSIGN expr
    (21) assignment -> . lvalue = expr
    (15) lvalue -> . _index
    (16) lvalue -> . ID
    (48) _index -> . ID [ idx_list ]
    }               shift and go to state 45
    ;               shift and go to state 4
    {               shift and go to state 5
    FOR             shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 7

    statement                      shift and go to state 17
    assignment                     shift and go to state 14
    lvalue                         shift and go to state 15
    _index                         shift and go to state 16

state 19

    (6) statement -> FOR ID . = range_expr statement
    =               shift and go to state 46


state 20

    (48) _index -> ID [ . idx_list ]
    (49) idx_list -> . idx_list , INTNUM
    (50) idx_list -> . INTNUM
    INTNUM          shift and go to state 48

    idx_list                       shift and go to state 47

state 21

    (7) statement -> WHILE ( . condition ) statement
    (22) condition -> . expr GE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LE expr
    (25) condition -> . expr LT expr
    (26) condition -> . expr NE expr
    (27) condition -> . expr EQ expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    condition                      shift and go to state 49
    expr                           shift and go to state 50
    _index                         shift and go to state 33

state 22

    (8) statement -> IF ( . condition ) statement ELSE statement
    (9) statement -> IF ( . condition ) statement
    (22) condition -> . expr GE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LE expr
    (25) condition -> . expr LT expr
    (26) condition -> . expr NE expr
    (27) condition -> . expr EQ expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    condition                      shift and go to state 51
    expr                           shift and go to state 50
    _index                         shift and go to state 33

state 23

    (10) statement -> PRINT elements . ;
    (53) elements -> elements . , expr
    ;               shift and go to state 52
    ,               shift and go to state 53


state 24

    (54) elements -> expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               reduce using rule 54 (elements -> expr .)
    ,               reduce using rule 54 (elements -> expr .)
    ]               reduce using rule 54 (elements -> expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 25

    (28) expr -> STRING .
    '               reduce using rule 28 (expr -> STRING .)
    DOTDIV          reduce using rule 28 (expr -> STRING .)
    DOTMUL          reduce using rule 28 (expr -> STRING .)
    DIVIDE          reduce using rule 28 (expr -> STRING .)
    TIMES           reduce using rule 28 (expr -> STRING .)
    DOTSUB          reduce using rule 28 (expr -> STRING .)
    DOTADD          reduce using rule 28 (expr -> STRING .)
    MINUS           reduce using rule 28 (expr -> STRING .)
    PLUS            reduce using rule 28 (expr -> STRING .)
    ;               reduce using rule 28 (expr -> STRING .)
    ,               reduce using rule 28 (expr -> STRING .)
    GE              reduce using rule 28 (expr -> STRING .)
    GT              reduce using rule 28 (expr -> STRING .)
    LE              reduce using rule 28 (expr -> STRING .)
    LT              reduce using rule 28 (expr -> STRING .)
    NE              reduce using rule 28 (expr -> STRING .)
    EQ              reduce using rule 28 (expr -> STRING .)
    )               reduce using rule 28 (expr -> STRING .)
    ]               reduce using rule 28 (expr -> STRING .)
    :               reduce using rule 28 (expr -> STRING .)
    {               reduce using rule 28 (expr -> STRING .)
    FOR             reduce using rule 28 (expr -> STRING .)
    WHILE           reduce using rule 28 (expr -> STRING .)
    IF              reduce using rule 28 (expr -> STRING .)
    PRINT           reduce using rule 28 (expr -> STRING .)
    RETURN          reduce using rule 28 (expr -> STRING .)
    CONTINUE        reduce using rule 28 (expr -> STRING .)
    BREAK           reduce using rule 28 (expr -> STRING .)
    ID              reduce using rule 28 (expr -> STRING .)


state 26

    (29) expr -> FLOATNUM .
    '               reduce using rule 29 (expr -> FLOATNUM .)
    DOTDIV          reduce using rule 29 (expr -> FLOATNUM .)
    DOTMUL          reduce using rule 29 (expr -> FLOATNUM .)
    DIVIDE          reduce using rule 29 (expr -> FLOATNUM .)
    TIMES           reduce using rule 29 (expr -> FLOATNUM .)
    DOTSUB          reduce using rule 29 (expr -> FLOATNUM .)
    DOTADD          reduce using rule 29 (expr -> FLOATNUM .)
    MINUS           reduce using rule 29 (expr -> FLOATNUM .)
    PLUS            reduce using rule 29 (expr -> FLOATNUM .)
    ;               reduce using rule 29 (expr -> FLOATNUM .)
    ,               reduce using rule 29 (expr -> FLOATNUM .)
    GE              reduce using rule 29 (expr -> FLOATNUM .)
    GT              reduce using rule 29 (expr -> FLOATNUM .)
    LE              reduce using rule 29 (expr -> FLOATNUM .)
    LT              reduce using rule 29 (expr -> FLOATNUM .)
    NE              reduce using rule 29 (expr -> FLOATNUM .)
    EQ              reduce using rule 29 (expr -> FLOATNUM .)
    )               reduce using rule 29 (expr -> FLOATNUM .)
    ]               reduce using rule 29 (expr -> FLOATNUM .)
    :               reduce using rule 29 (expr -> FLOATNUM .)
    {               reduce using rule 29 (expr -> FLOATNUM .)
    FOR             reduce using rule 29 (expr -> FLOATNUM .)
    WHILE           reduce using rule 29 (expr -> FLOATNUM .)
    IF              reduce using rule 29 (expr -> FLOATNUM .)
    PRINT           reduce using rule 29 (expr -> FLOATNUM .)
    RETURN          reduce using rule 29 (expr -> FLOATNUM .)
    CONTINUE        reduce using rule 29 (expr -> FLOATNUM .)
    BREAK           reduce using rule 29 (expr -> FLOATNUM .)
    ID              reduce using rule 29 (expr -> FLOATNUM .)


state 27

    (30) expr -> INTNUM .
    '               reduce using rule 30 (expr -> INTNUM .)
    DOTDIV          reduce using rule 30 (expr -> INTNUM .)
    DOTMUL          reduce using rule 30 (expr -> INTNUM .)
    DIVIDE          reduce using rule 30 (expr -> INTNUM .)
    TIMES           reduce using rule 30 (expr -> INTNUM .)
    DOTSUB          reduce using rule 30 (expr -> INTNUM .)
    DOTADD          reduce using rule 30 (expr -> INTNUM .)
    MINUS           reduce using rule 30 (expr -> INTNUM .)
    PLUS            reduce using rule 30 (expr -> INTNUM .)
    ;               reduce using rule 30 (expr -> INTNUM .)
    ,               reduce using rule 30 (expr -> INTNUM .)
    GE              reduce using rule 30 (expr -> INTNUM .)
    GT              reduce using rule 30 (expr -> INTNUM .)
    LE              reduce using rule 30 (expr -> INTNUM .)
    LT              reduce using rule 30 (expr -> INTNUM .)
    NE              reduce using rule 30 (expr -> INTNUM .)
    EQ              reduce using rule 30 (expr -> INTNUM .)
    )               reduce using rule 30 (expr -> INTNUM .)
    ]               reduce using rule 30 (expr -> INTNUM .)
    :               reduce using rule 30 (expr -> INTNUM .)
    {               reduce using rule 30 (expr -> INTNUM .)
    FOR             reduce using rule 30 (expr -> INTNUM .)
    WHILE           reduce using rule 30 (expr -> INTNUM .)
    IF              reduce using rule 30 (expr -> INTNUM .)
    PRINT           reduce using rule 30 (expr -> INTNUM .)
    RETURN          reduce using rule 30 (expr -> INTNUM .)
    CONTINUE        reduce using rule 30 (expr -> INTNUM .)
    BREAK           reduce using rule 30 (expr -> INTNUM .)
    ID              reduce using rule 30 (expr -> INTNUM .)


state 28

    (31) expr -> ( . expr )
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 63
    _index                         shift and go to state 33

state 29

    (32) expr -> [ . rows ]
    (51) rows -> . rows ; elements
    (52) rows -> . elements
    (53) elements -> . elements , expr
    (54) elements -> . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    rows                           shift and go to state 64
    elements                       shift and go to state 65
    expr                           shift and go to state 24
    _index                         shift and go to state 33

state 30

    (33) expr -> ZEROS . ( idx_list )
    (               shift and go to state 66


state 31

    (34) expr -> EYE . ( idx_list )
    (               shift and go to state 67


state 32

    (35) expr -> ONES . ( idx_list )
    (               shift and go to state 68


state 33

    (36) expr -> _index .
    '               reduce using rule 36 (expr -> _index .)
    DOTDIV          reduce using rule 36 (expr -> _index .)
    DOTMUL          reduce using rule 36 (expr -> _index .)
    DIVIDE          reduce using rule 36 (expr -> _index .)
    TIMES           reduce using rule 36 (expr -> _index .)
    DOTSUB          reduce using rule 36 (expr -> _index .)
    DOTADD          reduce using rule 36 (expr -> _index .)
    MINUS           reduce using rule 36 (expr -> _index .)
    PLUS            reduce using rule 36 (expr -> _index .)
    ;               reduce using rule 36 (expr -> _index .)
    ,               reduce using rule 36 (expr -> _index .)
    GE              reduce using rule 36 (expr -> _index .)
    GT              reduce using rule 36 (expr -> _index .)
    LE              reduce using rule 36 (expr -> _index .)
    LT              reduce using rule 36 (expr -> _index .)
    NE              reduce using rule 36 (expr -> _index .)
    EQ              reduce using rule 36 (expr -> _index .)
    )               reduce using rule 36 (expr -> _index .)
    ]               reduce using rule 36 (expr -> _index .)
    :               reduce using rule 36 (expr -> _index .)
    {               reduce using rule 36 (expr -> _index .)
    FOR             reduce using rule 36 (expr -> _index .)
    WHILE           reduce using rule 36 (expr -> _index .)
    IF              reduce using rule 36 (expr -> _index .)
    PRINT           reduce using rule 36 (expr -> _index .)
    RETURN          reduce using rule 36 (expr -> _index .)
    CONTINUE        reduce using rule 36 (expr -> _index .)
    BREAK           reduce using rule 36 (expr -> _index .)
    ID              reduce using rule 36 (expr -> _index .)


state 34

    (37) expr -> ID .
    (48) _index -> ID . [ idx_list ]
    '               reduce using rule 37 (expr -> ID .)
    DOTDIV          reduce using rule 37 (expr -> ID .)
    DOTMUL          reduce using rule 37 (expr -> ID .)
    DIVIDE          reduce using rule 37 (expr -> ID .)
    TIMES           reduce using rule 37 (expr -> ID .)
    DOTSUB          reduce using rule 37 (expr -> ID .)
    DOTADD          reduce using rule 37 (expr -> ID .)
    MINUS           reduce using rule 37 (expr -> ID .)
    PLUS            reduce using rule 37 (expr -> ID .)
    ;               reduce using rule 37 (expr -> ID .)
    ,               reduce using rule 37 (expr -> ID .)
    GE              reduce using rule 37 (expr -> ID .)
    GT              reduce using rule 37 (expr -> ID .)
    LE              reduce using rule 37 (expr -> ID .)
    LT              reduce using rule 37 (expr -> ID .)
    NE              reduce using rule 37 (expr -> ID .)
    EQ              reduce using rule 37 (expr -> ID .)
    )               reduce using rule 37 (expr -> ID .)
    ]               reduce using rule 37 (expr -> ID .)
    :               reduce using rule 37 (expr -> ID .)
    {               reduce using rule 37 (expr -> ID .)
    FOR             reduce using rule 37 (expr -> ID .)
    WHILE           reduce using rule 37 (expr -> ID .)
    IF              reduce using rule 37 (expr -> ID .)
    PRINT           reduce using rule 37 (expr -> ID .)
    RETURN          reduce using rule 37 (expr -> ID .)
    CONTINUE        reduce using rule 37 (expr -> ID .)
    BREAK           reduce using rule 37 (expr -> ID .)
    ID              reduce using rule 37 (expr -> ID .)
    [               shift and go to state 20


state 35

    (39) expr -> MINUS . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 69
    _index                         shift and go to state 33

state 36

    (11) statement -> RETURN expr . ;
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               shift and go to state 70
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 37

    (12) statement -> CONTINUE ; .
    ;               reduce using rule 12 (statement -> CONTINUE ; .)
    {               reduce using rule 12 (statement -> CONTINUE ; .)
    FOR             reduce using rule 12 (statement -> CONTINUE ; .)
    WHILE           reduce using rule 12 (statement -> CONTINUE ; .)
    IF              reduce using rule 12 (statement -> CONTINUE ; .)
    PRINT           reduce using rule 12 (statement -> CONTINUE ; .)
    RETURN          reduce using rule 12 (statement -> CONTINUE ; .)
    CONTINUE        reduce using rule 12 (statement -> CONTINUE ; .)
    BREAK           reduce using rule 12 (statement -> CONTINUE ; .)
    ID              reduce using rule 12 (statement -> CONTINUE ; .)
    $end            reduce using rule 12 (statement -> CONTINUE ; .)
    }               reduce using rule 12 (statement -> CONTINUE ; .)
    ELSE            reduce using rule 12 (statement -> CONTINUE ; .)


state 38

    (13) statement -> BREAK ; .
    ;               reduce using rule 13 (statement -> BREAK ; .)
    {               reduce using rule 13 (statement -> BREAK ; .)
    FOR             reduce using rule 13 (statement -> BREAK ; .)
    WHILE           reduce using rule 13 (statement -> BREAK ; .)
    IF              reduce using rule 13 (statement -> BREAK ; .)
    PRINT           reduce using rule 13 (statement -> BREAK ; .)
    RETURN          reduce using rule 13 (statement -> BREAK ; .)
    CONTINUE        reduce using rule 13 (statement -> BREAK ; .)
    BREAK           reduce using rule 13 (statement -> BREAK ; .)
    ID              reduce using rule 13 (statement -> BREAK ; .)
    $end            reduce using rule 13 (statement -> BREAK ; .)
    }               reduce using rule 13 (statement -> BREAK ; .)
    ELSE            reduce using rule 13 (statement -> BREAK ; .)


state 39

    (14) statement -> assignment ; .
    ;               reduce using rule 14 (statement -> assignment ; .)
    {               reduce using rule 14 (statement -> assignment ; .)
    FOR             reduce using rule 14 (statement -> assignment ; .)
    WHILE           reduce using rule 14 (statement -> assignment ; .)
    IF              reduce using rule 14 (statement -> assignment ; .)
    PRINT           reduce using rule 14 (statement -> assignment ; .)
    RETURN          reduce using rule 14 (statement -> assignment ; .)
    CONTINUE        reduce using rule 14 (statement -> assignment ; .)
    BREAK           reduce using rule 14 (statement -> assignment ; .)
    ID              reduce using rule 14 (statement -> assignment ; .)
    $end            reduce using rule 14 (statement -> assignment ; .)
    }               reduce using rule 14 (statement -> assignment ; .)
    ELSE            reduce using rule 14 (statement -> assignment ; .)


state 40

    (17) assignment -> lvalue DIVASSIGN . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 71
    _index                         shift and go to state 33

state 41

    (18) assignment -> lvalue MULASSIGN . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 72
    _index                         shift and go to state 33

state 42

    (19) assignment -> lvalue SUBASSIGN . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 73
    _index                         shift and go to state 33

state 43

    (20) assignment -> lvalue ADDASSIGN . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 74
    _index                         shift and go to state 33

state 44

    (21) assignment -> lvalue = . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 75
    _index                         shift and go to state 33

state 45

    (5) statement -> { statements } .
    ;               reduce using rule 5 (statement -> { statements } .)
    {               reduce using rule 5 (statement -> { statements } .)
    FOR             reduce using rule 5 (statement -> { statements } .)
    WHILE           reduce using rule 5 (statement -> { statements } .)
    IF              reduce using rule 5 (statement -> { statements } .)
    PRINT           reduce using rule 5 (statement -> { statements } .)
    RETURN          reduce using rule 5 (statement -> { statements } .)
    CONTINUE        reduce using rule 5 (statement -> { statements } .)
    BREAK           reduce using rule 5 (statement -> { statements } .)
    ID              reduce using rule 5 (statement -> { statements } .)
    $end            reduce using rule 5 (statement -> { statements } .)
    }               reduce using rule 5 (statement -> { statements } .)
    ELSE            reduce using rule 5 (statement -> { statements } .)


state 46

    (6) statement -> FOR ID = . range_expr statement
    (55) range_expr -> . expr : expr
    (56) range_expr -> . expr : expr : expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    range_expr                     shift and go to state 76
    expr                           shift and go to state 77
    _index                         shift and go to state 33

state 47

    (48) _index -> ID [ idx_list . ]
    (49) idx_list -> idx_list . , INTNUM
    ]               shift and go to state 78
    ,               shift and go to state 79


state 48

    (50) idx_list -> INTNUM .
    ]               reduce using rule 50 (idx_list -> INTNUM .)
    ,               reduce using rule 50 (idx_list -> INTNUM .)
    )               reduce using rule 50 (idx_list -> INTNUM .)


state 49

    (7) statement -> WHILE ( condition . ) statement
    )               shift and go to state 80


state 50

    (22) condition -> expr . GE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LE expr
    (25) condition -> expr . LT expr
    (26) condition -> expr . NE expr
    (27) condition -> expr . EQ expr
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    NE              shift and go to state 85
    EQ              shift and go to state 86
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 51

    (8) statement -> IF ( condition . ) statement ELSE statement
    (9) statement -> IF ( condition . ) statement
    )               shift and go to state 87


state 52

    (10) statement -> PRINT elements ; .
    ;               reduce using rule 10 (statement -> PRINT elements ; .)
    {               reduce using rule 10 (statement -> PRINT elements ; .)
    FOR             reduce using rule 10 (statement -> PRINT elements ; .)
    WHILE           reduce using rule 10 (statement -> PRINT elements ; .)
    IF              reduce using rule 10 (statement -> PRINT elements ; .)
    PRINT           reduce using rule 10 (statement -> PRINT elements ; .)
    RETURN          reduce using rule 10 (statement -> PRINT elements ; .)
    CONTINUE        reduce using rule 10 (statement -> PRINT elements ; .)
    BREAK           reduce using rule 10 (statement -> PRINT elements ; .)
    ID              reduce using rule 10 (statement -> PRINT elements ; .)
    $end            reduce using rule 10 (statement -> PRINT elements ; .)
    }               reduce using rule 10 (statement -> PRINT elements ; .)
    ELSE            reduce using rule 10 (statement -> PRINT elements ; .)


state 53

    (53) elements -> elements , . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 88
    _index                         shift and go to state 33

state 54

    (38) expr -> expr ' .
    '               reduce using rule 38 (expr -> expr ' .)
    DOTDIV          reduce using rule 38 (expr -> expr ' .)
    DOTMUL          reduce using rule 38 (expr -> expr ' .)
    DIVIDE          reduce using rule 38 (expr -> expr ' .)
    TIMES           reduce using rule 38 (expr -> expr ' .)
    DOTSUB          reduce using rule 38 (expr -> expr ' .)
    DOTADD          reduce using rule 38 (expr -> expr ' .)
    MINUS           reduce using rule 38 (expr -> expr ' .)
    PLUS            reduce using rule 38 (expr -> expr ' .)
    ;               reduce using rule 38 (expr -> expr ' .)
    ,               reduce using rule 38 (expr -> expr ' .)
    GE              reduce using rule 38 (expr -> expr ' .)
    GT              reduce using rule 38 (expr -> expr ' .)
    LE              reduce using rule 38 (expr -> expr ' .)
    LT              reduce using rule 38 (expr -> expr ' .)
    NE              reduce using rule 38 (expr -> expr ' .)
    EQ              reduce using rule 38 (expr -> expr ' .)
    )               reduce using rule 38 (expr -> expr ' .)
    ]               reduce using rule 38 (expr -> expr ' .)
    :               reduce using rule 38 (expr -> expr ' .)
    {               reduce using rule 38 (expr -> expr ' .)
    FOR             reduce using rule 38 (expr -> expr ' .)
    WHILE           reduce using rule 38 (expr -> expr ' .)
    IF              reduce using rule 38 (expr -> expr ' .)
    PRINT           reduce using rule 38 (expr -> expr ' .)
    RETURN          reduce using rule 38 (expr -> expr ' .)
    CONTINUE        reduce using rule 38 (expr -> expr ' .)
    BREAK           reduce using rule 38 (expr -> expr ' .)
    ID              reduce using rule 38 (expr -> expr ' .)


state 55

    (40) expr -> expr DOTDIV . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 89
    _index                         shift and go to state 33

state 56

    (41) expr -> expr DOTMUL . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 90
    _index                         shift and go to state 33

state 57

    (42) expr -> expr DIVIDE . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 91
    _index                         shift and go to state 33

state 58

    (43) expr -> expr TIMES . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 92
    _index                         shift and go to state 33

state 59

    (44) expr -> expr DOTSUB . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 93
    _index                         shift and go to state 33

state 60

    (45) expr -> expr DOTADD . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 94
    _index                         shift and go to state 33

state 61

    (46) expr -> expr MINUS . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 95
    _index                         shift and go to state 33

state 62

    (47) expr -> expr PLUS . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 96
    _index                         shift and go to state 33

state 63

    (31) expr -> ( expr . )
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    )               shift and go to state 97
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 64

    (32) expr -> [ rows . ]
    (51) rows -> rows . ; elements
    ]               shift and go to state 98
    ;               shift and go to state 99


state 65

    (52) rows -> elements .
    (53) elements -> elements . , expr
    ]               reduce using rule 52 (rows -> elements .)
    ;               reduce using rule 52 (rows -> elements .)
    ,               shift and go to state 53


state 66

    (33) expr -> ZEROS ( . idx_list )
    (49) idx_list -> . idx_list , INTNUM
    (50) idx_list -> . INTNUM
    INTNUM          shift and go to state 48

    idx_list                       shift and go to state 100

state 67

    (34) expr -> EYE ( . idx_list )
    (49) idx_list -> . idx_list , INTNUM
    (50) idx_list -> . INTNUM
    INTNUM          shift and go to state 48

    idx_list                       shift and go to state 101

state 68

    (35) expr -> ONES ( . idx_list )
    (49) idx_list -> . idx_list , INTNUM
    (50) idx_list -> . INTNUM
    INTNUM          shift and go to state 48

    idx_list                       shift and go to state 102

state 69

    (39) expr -> MINUS expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    DOTDIV          reduce using rule 39 (expr -> MINUS expr .)
    DOTMUL          reduce using rule 39 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 39 (expr -> MINUS expr .)
    TIMES           reduce using rule 39 (expr -> MINUS expr .)
    DOTSUB          reduce using rule 39 (expr -> MINUS expr .)
    DOTADD          reduce using rule 39 (expr -> MINUS expr .)
    MINUS           reduce using rule 39 (expr -> MINUS expr .)
    PLUS            reduce using rule 39 (expr -> MINUS expr .)
    ;               reduce using rule 39 (expr -> MINUS expr .)
    ,               reduce using rule 39 (expr -> MINUS expr .)
    GE              reduce using rule 39 (expr -> MINUS expr .)
    GT              reduce using rule 39 (expr -> MINUS expr .)
    LE              reduce using rule 39 (expr -> MINUS expr .)
    LT              reduce using rule 39 (expr -> MINUS expr .)
    NE              reduce using rule 39 (expr -> MINUS expr .)
    EQ              reduce using rule 39 (expr -> MINUS expr .)
    )               reduce using rule 39 (expr -> MINUS expr .)
    ]               reduce using rule 39 (expr -> MINUS expr .)
    :               reduce using rule 39 (expr -> MINUS expr .)
    {               reduce using rule 39 (expr -> MINUS expr .)
    FOR             reduce using rule 39 (expr -> MINUS expr .)
    WHILE           reduce using rule 39 (expr -> MINUS expr .)
    IF              reduce using rule 39 (expr -> MINUS expr .)
    PRINT           reduce using rule 39 (expr -> MINUS expr .)
    RETURN          reduce using rule 39 (expr -> MINUS expr .)
    CONTINUE        reduce using rule 39 (expr -> MINUS expr .)
    BREAK           reduce using rule 39 (expr -> MINUS expr .)
    ID              reduce using rule 39 (expr -> MINUS expr .)
    '               shift and go to state 54


state 70

    (11) statement -> RETURN expr ; .
    ;               reduce using rule 11 (statement -> RETURN expr ; .)
    {               reduce using rule 11 (statement -> RETURN expr ; .)
    FOR             reduce using rule 11 (statement -> RETURN expr ; .)
    WHILE           reduce using rule 11 (statement -> RETURN expr ; .)
    IF              reduce using rule 11 (statement -> RETURN expr ; .)
    PRINT           reduce using rule 11 (statement -> RETURN expr ; .)
    RETURN          reduce using rule 11 (statement -> RETURN expr ; .)
    CONTINUE        reduce using rule 11 (statement -> RETURN expr ; .)
    BREAK           reduce using rule 11 (statement -> RETURN expr ; .)
    ID              reduce using rule 11 (statement -> RETURN expr ; .)
    $end            reduce using rule 11 (statement -> RETURN expr ; .)
    }               reduce using rule 11 (statement -> RETURN expr ; .)
    ELSE            reduce using rule 11 (statement -> RETURN expr ; .)


state 71

    (17) assignment -> lvalue DIVASSIGN expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               reduce using rule 17 (assignment -> lvalue DIVASSIGN expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 72

    (18) assignment -> lvalue MULASSIGN expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               reduce using rule 18 (assignment -> lvalue MULASSIGN expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 73

    (19) assignment -> lvalue SUBASSIGN expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               reduce using rule 19 (assignment -> lvalue SUBASSIGN expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 74

    (20) assignment -> lvalue ADDASSIGN expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               reduce using rule 20 (assignment -> lvalue ADDASSIGN expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 75

    (21) assignment -> lvalue = expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               reduce using rule 21 (assignment -> lvalue = expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 76

    (6) statement -> FOR ID = range_expr . statement
    (4) statement -> . ;
    (5) statement -> . { statements }
    (6) statement -> . FOR ID = range_expr statement
    (7) statement -> . WHILE ( condition ) statement
    (8) statement -> . IF ( condition ) statement ELSE statement
    (9) statement -> . IF ( condition ) statement
    (10) statement -> . PRINT elements ;
    (11) statement -> . RETURN expr ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . BREAK ;
    (14) statement -> . assignment ;
    (17) assignment -> . lvalue DIVASSIGN expr
    (18) assignment -> . lvalue MULASSIGN expr
    (19) assignment -> . lvalue SUBASSIGN expr
    (20) assignment -> . lvalue ADDASSIGN expr
    (21) assignment -> . lvalue = expr
    (15) lvalue -> . _index
    (16) lvalue -> . ID
    (48) _index -> . ID [ idx_list ]
    ;               shift and go to state 4
    {               shift and go to state 5
    FOR             shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 7

    statement                      shift and go to state 103
    assignment                     shift and go to state 14
    lvalue                         shift and go to state 15
    _index                         shift and go to state 16

state 77

    (55) range_expr -> expr . : expr
    (56) range_expr -> expr . : expr : expr
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    :               shift and go to state 104
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 78

    (48) _index -> ID [ idx_list ] .
    DIVASSIGN       reduce using rule 48 (_index -> ID [ idx_list ] .)
    MULASSIGN       reduce using rule 48 (_index -> ID [ idx_list ] .)
    SUBASSIGN       reduce using rule 48 (_index -> ID [ idx_list ] .)
    ADDASSIGN       reduce using rule 48 (_index -> ID [ idx_list ] .)
    =               reduce using rule 48 (_index -> ID [ idx_list ] .)
    '               reduce using rule 48 (_index -> ID [ idx_list ] .)
    DOTDIV          reduce using rule 48 (_index -> ID [ idx_list ] .)
    DOTMUL          reduce using rule 48 (_index -> ID [ idx_list ] .)
    DIVIDE          reduce using rule 48 (_index -> ID [ idx_list ] .)
    TIMES           reduce using rule 48 (_index -> ID [ idx_list ] .)
    DOTSUB          reduce using rule 48 (_index -> ID [ idx_list ] .)
    DOTADD          reduce using rule 48 (_index -> ID [ idx_list ] .)
    MINUS           reduce using rule 48 (_index -> ID [ idx_list ] .)
    PLUS            reduce using rule 48 (_index -> ID [ idx_list ] .)
    ;               reduce using rule 48 (_index -> ID [ idx_list ] .)
    ,               reduce using rule 48 (_index -> ID [ idx_list ] .)
    GE              reduce using rule 48 (_index -> ID [ idx_list ] .)
    GT              reduce using rule 48 (_index -> ID [ idx_list ] .)
    LE              reduce using rule 48 (_index -> ID [ idx_list ] .)
    LT              reduce using rule 48 (_index -> ID [ idx_list ] .)
    NE              reduce using rule 48 (_index -> ID [ idx_list ] .)
    EQ              reduce using rule 48 (_index -> ID [ idx_list ] .)
    )               reduce using rule 48 (_index -> ID [ idx_list ] .)
    ]               reduce using rule 48 (_index -> ID [ idx_list ] .)
    :               reduce using rule 48 (_index -> ID [ idx_list ] .)
    {               reduce using rule 48 (_index -> ID [ idx_list ] .)
    FOR             reduce using rule 48 (_index -> ID [ idx_list ] .)
    WHILE           reduce using rule 48 (_index -> ID [ idx_list ] .)
    IF              reduce using rule 48 (_index -> ID [ idx_list ] .)
    PRINT           reduce using rule 48 (_index -> ID [ idx_list ] .)
    RETURN          reduce using rule 48 (_index -> ID [ idx_list ] .)
    CONTINUE        reduce using rule 48 (_index -> ID [ idx_list ] .)
    BREAK           reduce using rule 48 (_index -> ID [ idx_list ] .)
    ID              reduce using rule 48 (_index -> ID [ idx_list ] .)


state 79

    (49) idx_list -> idx_list , . INTNUM
    INTNUM          shift and go to state 105


state 80

    (7) statement -> WHILE ( condition ) . statement
    (4) statement -> . ;
    (5) statement -> . { statements }
    (6) statement -> . FOR ID = range_expr statement
    (7) statement -> . WHILE ( condition ) statement
    (8) statement -> . IF ( condition ) statement ELSE statement
    (9) statement -> . IF ( condition ) statement
    (10) statement -> . PRINT elements ;
    (11) statement -> . RETURN expr ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . BREAK ;
    (14) statement -> . assignment ;
    (17) assignment -> . lvalue DIVASSIGN expr
    (18) assignment -> . lvalue MULASSIGN expr
    (19) assignment -> . lvalue SUBASSIGN expr
    (20) assignment -> . lvalue ADDASSIGN expr
    (21) assignment -> . lvalue = expr
    (15) lvalue -> . _index
    (16) lvalue -> . ID
    (48) _index -> . ID [ idx_list ]
    ;               shift and go to state 4
    {               shift and go to state 5
    FOR             shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 7

    statement                      shift and go to state 106
    assignment                     shift and go to state 14
    lvalue                         shift and go to state 15
    _index                         shift and go to state 16

state 81

    (22) condition -> expr GE . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 107
    _index                         shift and go to state 33

state 82

    (23) condition -> expr GT . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 108
    _index                         shift and go to state 33

state 83

    (24) condition -> expr LE . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 109
    _index                         shift and go to state 33

state 84

    (25) condition -> expr LT . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 110
    _index                         shift and go to state 33

state 85

    (26) condition -> expr NE . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 111
    _index                         shift and go to state 33

state 86

    (27) condition -> expr EQ . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 112
    _index                         shift and go to state 33

state 87

    (8) statement -> IF ( condition ) . statement ELSE statement
    (9) statement -> IF ( condition ) . statement
    (4) statement -> . ;
    (5) statement -> . { statements }
    (6) statement -> . FOR ID = range_expr statement
    (7) statement -> . WHILE ( condition ) statement
    (8) statement -> . IF ( condition ) statement ELSE statement
    (9) statement -> . IF ( condition ) statement
    (10) statement -> . PRINT elements ;
    (11) statement -> . RETURN expr ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . BREAK ;
    (14) statement -> . assignment ;
    (17) assignment -> . lvalue DIVASSIGN expr
    (18) assignment -> . lvalue MULASSIGN expr
    (19) assignment -> . lvalue SUBASSIGN expr
    (20) assignment -> . lvalue ADDASSIGN expr
    (21) assignment -> . lvalue = expr
    (15) lvalue -> . _index
    (16) lvalue -> . ID
    (48) _index -> . ID [ idx_list ]
    ;               shift and go to state 4
    {               shift and go to state 5
    FOR             shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 7

    statement                      shift and go to state 113
    assignment                     shift and go to state 14
    lvalue                         shift and go to state 15
    _index                         shift and go to state 16

state 88

    (53) elements -> elements , expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               reduce using rule 53 (elements -> elements , expr .)
    ,               reduce using rule 53 (elements -> elements , expr .)
    ]               reduce using rule 53 (elements -> elements , expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 89

    (40) expr -> expr DOTDIV expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    DOTDIV          reduce using rule 40 (expr -> expr DOTDIV expr .)
    DOTMUL          reduce using rule 40 (expr -> expr DOTDIV expr .)
    DIVIDE          reduce using rule 40 (expr -> expr DOTDIV expr .)
    TIMES           reduce using rule 40 (expr -> expr DOTDIV expr .)
    DOTSUB          reduce using rule 40 (expr -> expr DOTDIV expr .)
    DOTADD          reduce using rule 40 (expr -> expr DOTDIV expr .)
    MINUS           reduce using rule 40 (expr -> expr DOTDIV expr .)
    PLUS            reduce using rule 40 (expr -> expr DOTDIV expr .)
    ;               reduce using rule 40 (expr -> expr DOTDIV expr .)
    ,               reduce using rule 40 (expr -> expr DOTDIV expr .)
    GE              reduce using rule 40 (expr -> expr DOTDIV expr .)
    GT              reduce using rule 40 (expr -> expr DOTDIV expr .)
    LE              reduce using rule 40 (expr -> expr DOTDIV expr .)
    LT              reduce using rule 40 (expr -> expr DOTDIV expr .)
    NE              reduce using rule 40 (expr -> expr DOTDIV expr .)
    EQ              reduce using rule 40 (expr -> expr DOTDIV expr .)
    )               reduce using rule 40 (expr -> expr DOTDIV expr .)
    ]               reduce using rule 40 (expr -> expr DOTDIV expr .)
    :               reduce using rule 40 (expr -> expr DOTDIV expr .)
    {               reduce using rule 40 (expr -> expr DOTDIV expr .)
    FOR             reduce using rule 40 (expr -> expr DOTDIV expr .)
    WHILE           reduce using rule 40 (expr -> expr DOTDIV expr .)
    IF              reduce using rule 40 (expr -> expr DOTDIV expr .)
    PRINT           reduce using rule 40 (expr -> expr DOTDIV expr .)
    RETURN          reduce using rule 40 (expr -> expr DOTDIV expr .)
    CONTINUE        reduce using rule 40 (expr -> expr DOTDIV expr .)
    BREAK           reduce using rule 40 (expr -> expr DOTDIV expr .)
    ID              reduce using rule 40 (expr -> expr DOTDIV expr .)
    '               shift and go to state 54


state 90

    (41) expr -> expr DOTMUL expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    DOTDIV          reduce using rule 41 (expr -> expr DOTMUL expr .)
    DOTMUL          reduce using rule 41 (expr -> expr DOTMUL expr .)
    DIVIDE          reduce using rule 41 (expr -> expr DOTMUL expr .)
    TIMES           reduce using rule 41 (expr -> expr DOTMUL expr .)
    DOTSUB          reduce using rule 41 (expr -> expr DOTMUL expr .)
    DOTADD          reduce using rule 41 (expr -> expr DOTMUL expr .)
    MINUS           reduce using rule 41 (expr -> expr DOTMUL expr .)
    PLUS            reduce using rule 41 (expr -> expr DOTMUL expr .)
    ;               reduce using rule 41 (expr -> expr DOTMUL expr .)
    ,               reduce using rule 41 (expr -> expr DOTMUL expr .)
    GE              reduce using rule 41 (expr -> expr DOTMUL expr .)
    GT              reduce using rule 41 (expr -> expr DOTMUL expr .)
    LE              reduce using rule 41 (expr -> expr DOTMUL expr .)
    LT              reduce using rule 41 (expr -> expr DOTMUL expr .)
    NE              reduce using rule 41 (expr -> expr DOTMUL expr .)
    EQ              reduce using rule 41 (expr -> expr DOTMUL expr .)
    )               reduce using rule 41 (expr -> expr DOTMUL expr .)
    ]               reduce using rule 41 (expr -> expr DOTMUL expr .)
    :               reduce using rule 41 (expr -> expr DOTMUL expr .)
    {               reduce using rule 41 (expr -> expr DOTMUL expr .)
    FOR             reduce using rule 41 (expr -> expr DOTMUL expr .)
    WHILE           reduce using rule 41 (expr -> expr DOTMUL expr .)
    IF              reduce using rule 41 (expr -> expr DOTMUL expr .)
    PRINT           reduce using rule 41 (expr -> expr DOTMUL expr .)
    RETURN          reduce using rule 41 (expr -> expr DOTMUL expr .)
    CONTINUE        reduce using rule 41 (expr -> expr DOTMUL expr .)
    BREAK           reduce using rule 41 (expr -> expr DOTMUL expr .)
    ID              reduce using rule 41 (expr -> expr DOTMUL expr .)
    '               shift and go to state 54


state 91

    (42) expr -> expr DIVIDE expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    DOTDIV          reduce using rule 42 (expr -> expr DIVIDE expr .)
    DOTMUL          reduce using rule 42 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 42 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 42 (expr -> expr DIVIDE expr .)
    DOTSUB          reduce using rule 42 (expr -> expr DIVIDE expr .)
    DOTADD          reduce using rule 42 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 42 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 42 (expr -> expr DIVIDE expr .)
    ;               reduce using rule 42 (expr -> expr DIVIDE expr .)
    ,               reduce using rule 42 (expr -> expr DIVIDE expr .)
    GE              reduce using rule 42 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 42 (expr -> expr DIVIDE expr .)
    LE              reduce using rule 42 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 42 (expr -> expr DIVIDE expr .)
    NE              reduce using rule 42 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 42 (expr -> expr DIVIDE expr .)
    )               reduce using rule 42 (expr -> expr DIVIDE expr .)
    ]               reduce using rule 42 (expr -> expr DIVIDE expr .)
    :               reduce using rule 42 (expr -> expr DIVIDE expr .)
    {               reduce using rule 42 (expr -> expr DIVIDE expr .)
    FOR             reduce using rule 42 (expr -> expr DIVIDE expr .)
    WHILE           reduce using rule 42 (expr -> expr DIVIDE expr .)
    IF              reduce using rule 42 (expr -> expr DIVIDE expr .)
    PRINT           reduce using rule 42 (expr -> expr DIVIDE expr .)
    RETURN          reduce using rule 42 (expr -> expr DIVIDE expr .)
    CONTINUE        reduce using rule 42 (expr -> expr DIVIDE expr .)
    BREAK           reduce using rule 42 (expr -> expr DIVIDE expr .)
    ID              reduce using rule 42 (expr -> expr DIVIDE expr .)
    '               shift and go to state 54


state 92

    (43) expr -> expr TIMES expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    DOTDIV          reduce using rule 43 (expr -> expr TIMES expr .)
    DOTMUL          reduce using rule 43 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 43 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 43 (expr -> expr TIMES expr .)
    DOTSUB          reduce using rule 43 (expr -> expr TIMES expr .)
    DOTADD          reduce using rule 43 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 43 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 43 (expr -> expr TIMES expr .)
    ;               reduce using rule 43 (expr -> expr TIMES expr .)
    ,               reduce using rule 43 (expr -> expr TIMES expr .)
    GE              reduce using rule 43 (expr -> expr TIMES expr .)
    GT              reduce using rule 43 (expr -> expr TIMES expr .)
    LE              reduce using rule 43 (expr -> expr TIMES expr .)
    LT              reduce using rule 43 (expr -> expr TIMES expr .)
    NE              reduce using rule 43 (expr -> expr TIMES expr .)
    EQ              reduce using rule 43 (expr -> expr TIMES expr .)
    )               reduce using rule 43 (expr -> expr TIMES expr .)
    ]               reduce using rule 43 (expr -> expr TIMES expr .)
    :               reduce using rule 43 (expr -> expr TIMES expr .)
    {               reduce using rule 43 (expr -> expr TIMES expr .)
    FOR             reduce using rule 43 (expr -> expr TIMES expr .)
    WHILE           reduce using rule 43 (expr -> expr TIMES expr .)
    IF              reduce using rule 43 (expr -> expr TIMES expr .)
    PRINT           reduce using rule 43 (expr -> expr TIMES expr .)
    RETURN          reduce using rule 43 (expr -> expr TIMES expr .)
    CONTINUE        reduce using rule 43 (expr -> expr TIMES expr .)
    BREAK           reduce using rule 43 (expr -> expr TIMES expr .)
    ID              reduce using rule 43 (expr -> expr TIMES expr .)
    '               shift and go to state 54


state 93

    (44) expr -> expr DOTSUB expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    DOTSUB          reduce using rule 44 (expr -> expr DOTSUB expr .)
    DOTADD          reduce using rule 44 (expr -> expr DOTSUB expr .)
    MINUS           reduce using rule 44 (expr -> expr DOTSUB expr .)
    PLUS            reduce using rule 44 (expr -> expr DOTSUB expr .)
    ;               reduce using rule 44 (expr -> expr DOTSUB expr .)
    ,               reduce using rule 44 (expr -> expr DOTSUB expr .)
    GE              reduce using rule 44 (expr -> expr DOTSUB expr .)
    GT              reduce using rule 44 (expr -> expr DOTSUB expr .)
    LE              reduce using rule 44 (expr -> expr DOTSUB expr .)
    LT              reduce using rule 44 (expr -> expr DOTSUB expr .)
    NE              reduce using rule 44 (expr -> expr DOTSUB expr .)
    EQ              reduce using rule 44 (expr -> expr DOTSUB expr .)
    )               reduce using rule 44 (expr -> expr DOTSUB expr .)
    ]               reduce using rule 44 (expr -> expr DOTSUB expr .)
    :               reduce using rule 44 (expr -> expr DOTSUB expr .)
    {               reduce using rule 44 (expr -> expr DOTSUB expr .)
    FOR             reduce using rule 44 (expr -> expr DOTSUB expr .)
    WHILE           reduce using rule 44 (expr -> expr DOTSUB expr .)
    IF              reduce using rule 44 (expr -> expr DOTSUB expr .)
    PRINT           reduce using rule 44 (expr -> expr DOTSUB expr .)
    RETURN          reduce using rule 44 (expr -> expr DOTSUB expr .)
    CONTINUE        reduce using rule 44 (expr -> expr DOTSUB expr .)
    BREAK           reduce using rule 44 (expr -> expr DOTSUB expr .)
    ID              reduce using rule 44 (expr -> expr DOTSUB expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58


state 94

    (45) expr -> expr DOTADD expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    DOTSUB          reduce using rule 45 (expr -> expr DOTADD expr .)
    DOTADD          reduce using rule 45 (expr -> expr DOTADD expr .)
    MINUS           reduce using rule 45 (expr -> expr DOTADD expr .)
    PLUS            reduce using rule 45 (expr -> expr DOTADD expr .)
    ;               reduce using rule 45 (expr -> expr DOTADD expr .)
    ,               reduce using rule 45 (expr -> expr DOTADD expr .)
    GE              reduce using rule 45 (expr -> expr DOTADD expr .)
    GT              reduce using rule 45 (expr -> expr DOTADD expr .)
    LE              reduce using rule 45 (expr -> expr DOTADD expr .)
    LT              reduce using rule 45 (expr -> expr DOTADD expr .)
    NE              reduce using rule 45 (expr -> expr DOTADD expr .)
    EQ              reduce using rule 45 (expr -> expr DOTADD expr .)
    )               reduce using rule 45 (expr -> expr DOTADD expr .)
    ]               reduce using rule 45 (expr -> expr DOTADD expr .)
    :               reduce using rule 45 (expr -> expr DOTADD expr .)
    {               reduce using rule 45 (expr -> expr DOTADD expr .)
    FOR             reduce using rule 45 (expr -> expr DOTADD expr .)
    WHILE           reduce using rule 45 (expr -> expr DOTADD expr .)
    IF              reduce using rule 45 (expr -> expr DOTADD expr .)
    PRINT           reduce using rule 45 (expr -> expr DOTADD expr .)
    RETURN          reduce using rule 45 (expr -> expr DOTADD expr .)
    CONTINUE        reduce using rule 45 (expr -> expr DOTADD expr .)
    BREAK           reduce using rule 45 (expr -> expr DOTADD expr .)
    ID              reduce using rule 45 (expr -> expr DOTADD expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58


state 95

    (46) expr -> expr MINUS expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    DOTSUB          reduce using rule 46 (expr -> expr MINUS expr .)
    DOTADD          reduce using rule 46 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 46 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 46 (expr -> expr MINUS expr .)
    ;               reduce using rule 46 (expr -> expr MINUS expr .)
    ,               reduce using rule 46 (expr -> expr MINUS expr .)
    GE              reduce using rule 46 (expr -> expr MINUS expr .)
    GT              reduce using rule 46 (expr -> expr MINUS expr .)
    LE              reduce using rule 46 (expr -> expr MINUS expr .)
    LT              reduce using rule 46 (expr -> expr MINUS expr .)
    NE              reduce using rule 46 (expr -> expr MINUS expr .)
    EQ              reduce using rule 46 (expr -> expr MINUS expr .)
    )               reduce using rule 46 (expr -> expr MINUS expr .)
    ]               reduce using rule 46 (expr -> expr MINUS expr .)
    :               reduce using rule 46 (expr -> expr MINUS expr .)
    {               reduce using rule 46 (expr -> expr MINUS expr .)
    FOR             reduce using rule 46 (expr -> expr MINUS expr .)
    WHILE           reduce using rule 46 (expr -> expr MINUS expr .)
    IF              reduce using rule 46 (expr -> expr MINUS expr .)
    PRINT           reduce using rule 46 (expr -> expr MINUS expr .)
    RETURN          reduce using rule 46 (expr -> expr MINUS expr .)
    CONTINUE        reduce using rule 46 (expr -> expr MINUS expr .)
    BREAK           reduce using rule 46 (expr -> expr MINUS expr .)
    ID              reduce using rule 46 (expr -> expr MINUS expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58


state 96

    (47) expr -> expr PLUS expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    DOTSUB          reduce using rule 47 (expr -> expr PLUS expr .)
    DOTADD          reduce using rule 47 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 47 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 47 (expr -> expr PLUS expr .)
    ;               reduce using rule 47 (expr -> expr PLUS expr .)
    ,               reduce using rule 47 (expr -> expr PLUS expr .)
    GE              reduce using rule 47 (expr -> expr PLUS expr .)
    GT              reduce using rule 47 (expr -> expr PLUS expr .)
    LE              reduce using rule 47 (expr -> expr PLUS expr .)
    LT              reduce using rule 47 (expr -> expr PLUS expr .)
    NE              reduce using rule 47 (expr -> expr PLUS expr .)
    EQ              reduce using rule 47 (expr -> expr PLUS expr .)
    )               reduce using rule 47 (expr -> expr PLUS expr .)
    ]               reduce using rule 47 (expr -> expr PLUS expr .)
    :               reduce using rule 47 (expr -> expr PLUS expr .)
    {               reduce using rule 47 (expr -> expr PLUS expr .)
    FOR             reduce using rule 47 (expr -> expr PLUS expr .)
    WHILE           reduce using rule 47 (expr -> expr PLUS expr .)
    IF              reduce using rule 47 (expr -> expr PLUS expr .)
    PRINT           reduce using rule 47 (expr -> expr PLUS expr .)
    RETURN          reduce using rule 47 (expr -> expr PLUS expr .)
    CONTINUE        reduce using rule 47 (expr -> expr PLUS expr .)
    BREAK           reduce using rule 47 (expr -> expr PLUS expr .)
    ID              reduce using rule 47 (expr -> expr PLUS expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58


state 97

    (31) expr -> ( expr ) .
    '               reduce using rule 31 (expr -> ( expr ) .)
    DOTDIV          reduce using rule 31 (expr -> ( expr ) .)
    DOTMUL          reduce using rule 31 (expr -> ( expr ) .)
    DIVIDE          reduce using rule 31 (expr -> ( expr ) .)
    TIMES           reduce using rule 31 (expr -> ( expr ) .)
    DOTSUB          reduce using rule 31 (expr -> ( expr ) .)
    DOTADD          reduce using rule 31 (expr -> ( expr ) .)
    MINUS           reduce using rule 31 (expr -> ( expr ) .)
    PLUS            reduce using rule 31 (expr -> ( expr ) .)
    ;               reduce using rule 31 (expr -> ( expr ) .)
    ,               reduce using rule 31 (expr -> ( expr ) .)
    GE              reduce using rule 31 (expr -> ( expr ) .)
    GT              reduce using rule 31 (expr -> ( expr ) .)
    LE              reduce using rule 31 (expr -> ( expr ) .)
    LT              reduce using rule 31 (expr -> ( expr ) .)
    NE              reduce using rule 31 (expr -> ( expr ) .)
    EQ              reduce using rule 31 (expr -> ( expr ) .)
    )               reduce using rule 31 (expr -> ( expr ) .)
    ]               reduce using rule 31 (expr -> ( expr ) .)
    :               reduce using rule 31 (expr -> ( expr ) .)
    {               reduce using rule 31 (expr -> ( expr ) .)
    FOR             reduce using rule 31 (expr -> ( expr ) .)
    WHILE           reduce using rule 31 (expr -> ( expr ) .)
    IF              reduce using rule 31 (expr -> ( expr ) .)
    PRINT           reduce using rule 31 (expr -> ( expr ) .)
    RETURN          reduce using rule 31 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 31 (expr -> ( expr ) .)
    BREAK           reduce using rule 31 (expr -> ( expr ) .)
    ID              reduce using rule 31 (expr -> ( expr ) .)


state 98

    (32) expr -> [ rows ] .
    '               reduce using rule 32 (expr -> [ rows ] .)
    DOTDIV          reduce using rule 32 (expr -> [ rows ] .)
    DOTMUL          reduce using rule 32 (expr -> [ rows ] .)
    DIVIDE          reduce using rule 32 (expr -> [ rows ] .)
    TIMES           reduce using rule 32 (expr -> [ rows ] .)
    DOTSUB          reduce using rule 32 (expr -> [ rows ] .)
    DOTADD          reduce using rule 32 (expr -> [ rows ] .)
    MINUS           reduce using rule 32 (expr -> [ rows ] .)
    PLUS            reduce using rule 32 (expr -> [ rows ] .)
    ;               reduce using rule 32 (expr -> [ rows ] .)
    ,               reduce using rule 32 (expr -> [ rows ] .)
    GE              reduce using rule 32 (expr -> [ rows ] .)
    GT              reduce using rule 32 (expr -> [ rows ] .)
    LE              reduce using rule 32 (expr -> [ rows ] .)
    LT              reduce using rule 32 (expr -> [ rows ] .)
    NE              reduce using rule 32 (expr -> [ rows ] .)
    EQ              reduce using rule 32 (expr -> [ rows ] .)
    )               reduce using rule 32 (expr -> [ rows ] .)
    ]               reduce using rule 32 (expr -> [ rows ] .)
    :               reduce using rule 32 (expr -> [ rows ] .)
    {               reduce using rule 32 (expr -> [ rows ] .)
    FOR             reduce using rule 32 (expr -> [ rows ] .)
    WHILE           reduce using rule 32 (expr -> [ rows ] .)
    IF              reduce using rule 32 (expr -> [ rows ] .)
    PRINT           reduce using rule 32 (expr -> [ rows ] .)
    RETURN          reduce using rule 32 (expr -> [ rows ] .)
    CONTINUE        reduce using rule 32 (expr -> [ rows ] .)
    BREAK           reduce using rule 32 (expr -> [ rows ] .)
    ID              reduce using rule 32 (expr -> [ rows ] .)


state 99

    (51) rows -> rows ; . elements
    (53) elements -> . elements , expr
    (54) elements -> . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    elements                       shift and go to state 114
    expr                           shift and go to state 24
    _index                         shift and go to state 33

state 100

    (33) expr -> ZEROS ( idx_list . )
    (49) idx_list -> idx_list . , INTNUM
    )               shift and go to state 115
    ,               shift and go to state 79


state 101

    (34) expr -> EYE ( idx_list . )
    (49) idx_list -> idx_list . , INTNUM
    )               shift and go to state 116
    ,               shift and go to state 79


state 102

    (35) expr -> ONES ( idx_list . )
    (49) idx_list -> idx_list . , INTNUM
    )               shift and go to state 117
    ,               shift and go to state 79


state 103

    (6) statement -> FOR ID = range_expr statement .
    ;               reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    {               reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    FOR             reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    WHILE           reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    IF              reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    PRINT           reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    RETURN          reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    CONTINUE        reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    BREAK           reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    ID              reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    $end            reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    }               reduce using rule 6 (statement -> FOR ID = range_expr statement .)
    ELSE            reduce using rule 6 (statement -> FOR ID = range_expr statement .)


state 104

    (55) range_expr -> expr : . expr
    (56) range_expr -> expr : . expr : expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 118
    _index                         shift and go to state 33

state 105

    (49) idx_list -> idx_list , INTNUM .
    ]               reduce using rule 49 (idx_list -> idx_list , INTNUM .)
    ,               reduce using rule 49 (idx_list -> idx_list , INTNUM .)
    )               reduce using rule 49 (idx_list -> idx_list , INTNUM .)


state 106

    (7) statement -> WHILE ( condition ) statement .
    ;               reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    {               reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    FOR             reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    WHILE           reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    IF              reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    PRINT           reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    RETURN          reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    CONTINUE        reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    BREAK           reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    ID              reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    $end            reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    }               reduce using rule 7 (statement -> WHILE ( condition ) statement .)
    ELSE            reduce using rule 7 (statement -> WHILE ( condition ) statement .)


state 107

    (22) condition -> expr GE expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    )               reduce using rule 22 (condition -> expr GE expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 108

    (23) condition -> expr GT expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    )               reduce using rule 23 (condition -> expr GT expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 109

    (24) condition -> expr LE expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    )               reduce using rule 24 (condition -> expr LE expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 110

    (25) condition -> expr LT expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    )               reduce using rule 25 (condition -> expr LT expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 111

    (26) condition -> expr NE expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    )               reduce using rule 26 (condition -> expr NE expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 112

    (27) condition -> expr EQ expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    )               reduce using rule 27 (condition -> expr EQ expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 113

    (8) statement -> IF ( condition ) statement . ELSE statement
    (9) statement -> IF ( condition ) statement .
    ELSE            shift and go to state 119
    ;               reduce using rule 9 (statement -> IF ( condition ) statement .)
    {               reduce using rule 9 (statement -> IF ( condition ) statement .)
    FOR             reduce using rule 9 (statement -> IF ( condition ) statement .)
    WHILE           reduce using rule 9 (statement -> IF ( condition ) statement .)
    IF              reduce using rule 9 (statement -> IF ( condition ) statement .)
    PRINT           reduce using rule 9 (statement -> IF ( condition ) statement .)
    RETURN          reduce using rule 9 (statement -> IF ( condition ) statement .)
    CONTINUE        reduce using rule 9 (statement -> IF ( condition ) statement .)
    BREAK           reduce using rule 9 (statement -> IF ( condition ) statement .)
    ID              reduce using rule 9 (statement -> IF ( condition ) statement .)
    $end            reduce using rule 9 (statement -> IF ( condition ) statement .)
    }               reduce using rule 9 (statement -> IF ( condition ) statement .)


state 114

    (51) rows -> rows ; elements .
    (53) elements -> elements . , expr
    ]               reduce using rule 51 (rows -> rows ; elements .)
    ;               reduce using rule 51 (rows -> rows ; elements .)
    ,               shift and go to state 53


state 115

    (33) expr -> ZEROS ( idx_list ) .
    '               reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    DOTDIV          reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    DOTMUL          reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    DIVIDE          reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    TIMES           reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    DOTSUB          reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    DOTADD          reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    MINUS           reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    PLUS            reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    ;               reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    ,               reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    GE              reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    GT              reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    LE              reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    LT              reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    NE              reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    EQ              reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    )               reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    ]               reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    :               reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    {               reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    FOR             reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    WHILE           reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    IF              reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    PRINT           reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    RETURN          reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    CONTINUE        reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    BREAK           reduce using rule 33 (expr -> ZEROS ( idx_list ) .)
    ID              reduce using rule 33 (expr -> ZEROS ( idx_list ) .)


state 116

    (34) expr -> EYE ( idx_list ) .
    '               reduce using rule 34 (expr -> EYE ( idx_list ) .)
    DOTDIV          reduce using rule 34 (expr -> EYE ( idx_list ) .)
    DOTMUL          reduce using rule 34 (expr -> EYE ( idx_list ) .)
    DIVIDE          reduce using rule 34 (expr -> EYE ( idx_list ) .)
    TIMES           reduce using rule 34 (expr -> EYE ( idx_list ) .)
    DOTSUB          reduce using rule 34 (expr -> EYE ( idx_list ) .)
    DOTADD          reduce using rule 34 (expr -> EYE ( idx_list ) .)
    MINUS           reduce using rule 34 (expr -> EYE ( idx_list ) .)
    PLUS            reduce using rule 34 (expr -> EYE ( idx_list ) .)
    ;               reduce using rule 34 (expr -> EYE ( idx_list ) .)
    ,               reduce using rule 34 (expr -> EYE ( idx_list ) .)
    GE              reduce using rule 34 (expr -> EYE ( idx_list ) .)
    GT              reduce using rule 34 (expr -> EYE ( idx_list ) .)
    LE              reduce using rule 34 (expr -> EYE ( idx_list ) .)
    LT              reduce using rule 34 (expr -> EYE ( idx_list ) .)
    NE              reduce using rule 34 (expr -> EYE ( idx_list ) .)
    EQ              reduce using rule 34 (expr -> EYE ( idx_list ) .)
    )               reduce using rule 34 (expr -> EYE ( idx_list ) .)
    ]               reduce using rule 34 (expr -> EYE ( idx_list ) .)
    :               reduce using rule 34 (expr -> EYE ( idx_list ) .)
    {               reduce using rule 34 (expr -> EYE ( idx_list ) .)
    FOR             reduce using rule 34 (expr -> EYE ( idx_list ) .)
    WHILE           reduce using rule 34 (expr -> EYE ( idx_list ) .)
    IF              reduce using rule 34 (expr -> EYE ( idx_list ) .)
    PRINT           reduce using rule 34 (expr -> EYE ( idx_list ) .)
    RETURN          reduce using rule 34 (expr -> EYE ( idx_list ) .)
    CONTINUE        reduce using rule 34 (expr -> EYE ( idx_list ) .)
    BREAK           reduce using rule 34 (expr -> EYE ( idx_list ) .)
    ID              reduce using rule 34 (expr -> EYE ( idx_list ) .)


state 117

    (35) expr -> ONES ( idx_list ) .
    '               reduce using rule 35 (expr -> ONES ( idx_list ) .)
    DOTDIV          reduce using rule 35 (expr -> ONES ( idx_list ) .)
    DOTMUL          reduce using rule 35 (expr -> ONES ( idx_list ) .)
    DIVIDE          reduce using rule 35 (expr -> ONES ( idx_list ) .)
    TIMES           reduce using rule 35 (expr -> ONES ( idx_list ) .)
    DOTSUB          reduce using rule 35 (expr -> ONES ( idx_list ) .)
    DOTADD          reduce using rule 35 (expr -> ONES ( idx_list ) .)
    MINUS           reduce using rule 35 (expr -> ONES ( idx_list ) .)
    PLUS            reduce using rule 35 (expr -> ONES ( idx_list ) .)
    ;               reduce using rule 35 (expr -> ONES ( idx_list ) .)
    ,               reduce using rule 35 (expr -> ONES ( idx_list ) .)
    GE              reduce using rule 35 (expr -> ONES ( idx_list ) .)
    GT              reduce using rule 35 (expr -> ONES ( idx_list ) .)
    LE              reduce using rule 35 (expr -> ONES ( idx_list ) .)
    LT              reduce using rule 35 (expr -> ONES ( idx_list ) .)
    NE              reduce using rule 35 (expr -> ONES ( idx_list ) .)
    EQ              reduce using rule 35 (expr -> ONES ( idx_list ) .)
    )               reduce using rule 35 (expr -> ONES ( idx_list ) .)
    ]               reduce using rule 35 (expr -> ONES ( idx_list ) .)
    :               reduce using rule 35 (expr -> ONES ( idx_list ) .)
    {               reduce using rule 35 (expr -> ONES ( idx_list ) .)
    FOR             reduce using rule 35 (expr -> ONES ( idx_list ) .)
    WHILE           reduce using rule 35 (expr -> ONES ( idx_list ) .)
    IF              reduce using rule 35 (expr -> ONES ( idx_list ) .)
    PRINT           reduce using rule 35 (expr -> ONES ( idx_list ) .)
    RETURN          reduce using rule 35 (expr -> ONES ( idx_list ) .)
    CONTINUE        reduce using rule 35 (expr -> ONES ( idx_list ) .)
    BREAK           reduce using rule 35 (expr -> ONES ( idx_list ) .)
    ID              reduce using rule 35 (expr -> ONES ( idx_list ) .)


state 118

    (55) range_expr -> expr : expr .
    (56) range_expr -> expr : expr . : expr
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               reduce using rule 55 (range_expr -> expr : expr .)
    {               reduce using rule 55 (range_expr -> expr : expr .)
    FOR             reduce using rule 55 (range_expr -> expr : expr .)
    WHILE           reduce using rule 55 (range_expr -> expr : expr .)
    IF              reduce using rule 55 (range_expr -> expr : expr .)
    PRINT           reduce using rule 55 (range_expr -> expr : expr .)
    RETURN          reduce using rule 55 (range_expr -> expr : expr .)
    CONTINUE        reduce using rule 55 (range_expr -> expr : expr .)
    BREAK           reduce using rule 55 (range_expr -> expr : expr .)
    ID              reduce using rule 55 (range_expr -> expr : expr .)
    :               shift and go to state 120
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62


state 119

    (8) statement -> IF ( condition ) statement ELSE . statement
    (4) statement -> . ;
    (5) statement -> . { statements }
    (6) statement -> . FOR ID = range_expr statement
    (7) statement -> . WHILE ( condition ) statement
    (8) statement -> . IF ( condition ) statement ELSE statement
    (9) statement -> . IF ( condition ) statement
    (10) statement -> . PRINT elements ;
    (11) statement -> . RETURN expr ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . BREAK ;
    (14) statement -> . assignment ;
    (17) assignment -> . lvalue DIVASSIGN expr
    (18) assignment -> . lvalue MULASSIGN expr
    (19) assignment -> . lvalue SUBASSIGN expr
    (20) assignment -> . lvalue ADDASSIGN expr
    (21) assignment -> . lvalue = expr
    (15) lvalue -> . _index
    (16) lvalue -> . ID
    (48) _index -> . ID [ idx_list ]
    ;               shift and go to state 4
    {               shift and go to state 5
    FOR             shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 7

    statement                      shift and go to state 121
    assignment                     shift and go to state 14
    lvalue                         shift and go to state 15
    _index                         shift and go to state 16

state 120

    (56) range_expr -> expr : expr : . expr
    (28) expr -> . STRING
    (29) expr -> . FLOATNUM
    (30) expr -> . INTNUM
    (31) expr -> . ( expr )
    (32) expr -> . [ rows ]
    (33) expr -> . ZEROS ( idx_list )
    (34) expr -> . EYE ( idx_list )
    (35) expr -> . ONES ( idx_list )
    (36) expr -> . _index
    (37) expr -> . ID
    (38) expr -> . expr '
    (39) expr -> . MINUS expr
    (40) expr -> . expr DOTDIV expr
    (41) expr -> . expr DOTMUL expr
    (42) expr -> . expr DIVIDE expr
    (43) expr -> . expr TIMES expr
    (44) expr -> . expr DOTSUB expr
    (45) expr -> . expr DOTADD expr
    (46) expr -> . expr MINUS expr
    (47) expr -> . expr PLUS expr
    (48) _index -> . ID [ idx_list ]
    STRING          shift and go to state 25
    FLOATNUM        shift and go to state 26
    INTNUM          shift and go to state 27
    (               shift and go to state 28
    [               shift and go to state 29
    ZEROS           shift and go to state 30
    EYE             shift and go to state 31
    ONES            shift and go to state 32
    ID              shift and go to state 34
    MINUS           shift and go to state 35

    expr                           shift and go to state 122
    _index                         shift and go to state 33

state 121

    (8) statement -> IF ( condition ) statement ELSE statement .
    ;               reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    {               reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    FOR             reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    WHILE           reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    IF              reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    PRINT           reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    RETURN          reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    CONTINUE        reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    BREAK           reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    ID              reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    $end            reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    }               reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)
    ELSE            reduce using rule 8 (statement -> IF ( condition ) statement ELSE statement .)


state 122

    (56) range_expr -> expr : expr : expr .
    (38) expr -> expr . '
    (40) expr -> expr . DOTDIV expr
    (41) expr -> expr . DOTMUL expr
    (42) expr -> expr . DIVIDE expr
    (43) expr -> expr . TIMES expr
    (44) expr -> expr . DOTSUB expr
    (45) expr -> expr . DOTADD expr
    (46) expr -> expr . MINUS expr
    (47) expr -> expr . PLUS expr
    ;               reduce using rule 56 (range_expr -> expr : expr : expr .)
    {               reduce using rule 56 (range_expr -> expr : expr : expr .)
    FOR             reduce using rule 56 (range_expr -> expr : expr : expr .)
    WHILE           reduce using rule 56 (range_expr -> expr : expr : expr .)
    IF              reduce using rule 56 (range_expr -> expr : expr : expr .)
    PRINT           reduce using rule 56 (range_expr -> expr : expr : expr .)
    RETURN          reduce using rule 56 (range_expr -> expr : expr : expr .)
    CONTINUE        reduce using rule 56 (range_expr -> expr : expr : expr .)
    BREAK           reduce using rule 56 (range_expr -> expr : expr : expr .)
    ID              reduce using rule 56 (range_expr -> expr : expr : expr .)
    '               shift and go to state 54
    DOTDIV          shift and go to state 55
    DOTMUL          shift and go to state 56
    DIVIDE          shift and go to state 57
    TIMES           shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62
