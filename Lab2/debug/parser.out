Grammar:

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statement
Rule 3     statements -> statements statement
Rule 4     statement -> ;
Rule 5     statement -> compound_block
Rule 6     statement -> compound_stmt
Rule 7     statement -> simple_stmt ;
Rule 8     simple_stmt -> PRINT print_list
Rule 9     simple_stmt -> RETURN expr
Rule 10    simple_stmt -> CONTINUE
Rule 11    simple_stmt -> BREAK
Rule 12    simple_stmt -> expr
Rule 13    simple_stmt -> assignment
Rule 14    lvalue -> index
Rule 15    lvalue -> ID
Rule 16    assignment -> lvalue DIVASSIGN expr
Rule 17    assignment -> lvalue MULASSIGN expr
Rule 18    assignment -> lvalue SUBASSIGN expr
Rule 19    assignment -> lvalue ADDASSIGN expr
Rule 20    assignment -> lvalue = expr
Rule 21    print_list -> expr
Rule 22    print_list -> expr , print_list
Rule 23    compound_stmt -> FOR ID = range_expr statement
Rule 24    compound_stmt -> WHILE ( condition ) statement
Rule 25    compound_stmt -> IF ( condition ) statement ELSE statement  [precedence=nonassoc, level=2]
Rule 26    compound_stmt -> IF ( condition ) statement  [precedence=nonassoc, level=1]
Rule 27    compound_block -> { statements }
Rule 28    condition -> expr GE expr  [precedence=nonassoc, level=4]
Rule 29    condition -> expr GT expr  [precedence=nonassoc, level=4]
Rule 30    condition -> expr LE expr  [precedence=nonassoc, level=4]
Rule 31    condition -> expr LT expr  [precedence=nonassoc, level=4]
Rule 32    condition -> expr NE expr  [precedence=nonassoc, level=4]
Rule 33    condition -> expr EQ expr  [precedence=nonassoc, level=4]
Rule 34    expr -> term
Rule 35    expr -> expr DOTSUB term  [precedence=left, level=5]
Rule 36    expr -> expr DOTADD term  [precedence=left, level=5]
Rule 37    expr -> expr MINUS term  [precedence=left, level=5]
Rule 38    expr -> expr PLUS term  [precedence=left, level=5]
Rule 39    term -> NEGATE term  [precedence=right, level=7]
Rule 40    term -> MINUS term  [precedence=right, level=7]
Rule 41    term -> factor
Rule 42    term -> term DOTDIV factor  [precedence=left, level=6]
Rule 43    term -> term DOTMUL factor  [precedence=left, level=6]
Rule 44    term -> term DIVIDE factor  [precedence=left, level=6]
Rule 45    term -> term TIMES factor  [precedence=left, level=6]
Rule 46    index -> ID [ idx_list ]
Rule 47    factor -> STRING
Rule 48    factor -> SCINOTATION
Rule 49    factor -> FLOATNUM
Rule 50    factor -> INTNUM
Rule 51    factor -> ( expr )
Rule 52    factor -> matrix_literal
Rule 53    factor -> ZEROS ( idx_list )
Rule 54    factor -> EYE ( idx_list )
Rule 55    factor -> ONES ( idx_list )
Rule 56    factor -> factor '  [precedence=right, level=8]
Rule 57    factor -> index
Rule 58    factor -> ID
Rule 59    idx_list -> idx_list , INTNUM
Rule 60    idx_list -> INTNUM
Rule 61    matrix_literal -> [ rows ]
Rule 62    rows -> rows ; row
Rule 63    rows -> row
Rule 64    row -> elements
Rule 65    elements -> elements , expr
Rule 66    elements -> expr
Rule 67    range_expr -> expr : expr  [precedence=nonassoc, level=3]
Rule 68    range_expr -> expr : expr : expr  [precedence=nonassoc, level=3]

Terminals, with rules where they appear:

'                    : 56
(                    : 24 25 26 51 53 54 55
)                    : 24 25 26 51 53 54 55
,                    : 22 59 65
:                    : 67 68 68
;                    : 4 7 62
=                    : 20 23
ADDASSIGN            : 19
BREAK                : 11
CONTINUE             : 10
DIVASSIGN            : 16
DIVIDE               : 44
DOTADD               : 36
DOTDIV               : 42
DOTMUL               : 43
DOTSUB               : 35
ELSE                 : 25
EQ                   : 33
EYE                  : 54
FLOATNUM             : 49
FOR                  : 23
GE                   : 28
GT                   : 29
ID                   : 15 23 46 58
IF                   : 25 26
INTNUM               : 50 59 60
LE                   : 30
LT                   : 31
MINUS                : 37 40
MULASSIGN            : 17
NE                   : 32
NEGATE               : 39
ONES                 : 55
PLUS                 : 38
PRINT                : 8
RETURN               : 9
SCINOTATION          : 48
STRING               : 47
SUBASSIGN            : 18
TIMES                : 45
WHILE                : 24
ZEROS                : 53
[                    : 46 61
]                    : 46 61
error                : 
{                    : 27
}                    : 27

Nonterminals, with rules where they appear:

assignment           : 13
compound_block       : 5
compound_stmt        : 6
condition            : 24 25 26
elements             : 64 65
expr                 : 9 12 16 17 18 19 20 21 22 28 28 29 29 30 30 31 31 32 32 33 33 35 36 37 38 51 65 66 67 67 68 68 68
factor               : 41 42 43 44 45 56
idx_list             : 46 53 54 55 59
index                : 14 57
lvalue               : 16 17 18 19 20
matrix_literal       : 52
print_list           : 8 22
program              : 0
range_expr           : 23
row                  : 62 63
rows                 : 61 62
simple_stmt          : 7
statement            : 2 3 23 24 25 25 26
statements           : 1 3 27
term                 : 34 35 36 37 38 39 40 42 43 44 45


state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . ;
    (5) statement -> . compound_block
    (6) statement -> . compound_stmt
    (7) statement -> . simple_stmt ;
    (27) compound_block -> . { statements }
    (23) compound_stmt -> . FOR ID = range_expr statement
    (24) compound_stmt -> . WHILE ( condition ) statement
    (25) compound_stmt -> . IF ( condition ) statement ELSE statement
    (26) compound_stmt -> . IF ( condition ) statement
    (8) simple_stmt -> . PRINT print_list
    (9) simple_stmt -> . RETURN expr
    (10) simple_stmt -> . CONTINUE
    (11) simple_stmt -> . BREAK
    (12) simple_stmt -> . expr
    (13) simple_stmt -> . assignment
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (16) assignment -> . lvalue DIVASSIGN expr
    (17) assignment -> . lvalue MULASSIGN expr
    (18) assignment -> . lvalue SUBASSIGN expr
    (19) assignment -> . lvalue ADDASSIGN expr
    (20) assignment -> . lvalue = expr
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (14) lvalue -> . index
    (15) lvalue -> . ID
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (46) index -> . ID [ idx_list ]
    (61) matrix_literal -> . [ rows ]
    ;               shift and go to state 4
    {               shift and go to state 8
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 13
    PRINT           shift and go to state 14
    RETURN          shift and go to state 15
    CONTINUE        shift and go to state 17
    BREAK           shift and go to state 18
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    ID              shift and go to state 10
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    [               shift and go to state 34

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    compound_block                 shift and go to state 5
    compound_stmt                  shift and go to state 6
    simple_stmt                    shift and go to state 7
    expr                           shift and go to state 16
    assignment                     shift and go to state 19
    term                           shift and go to state 20
    lvalue                         shift and go to state 22
    factor                         shift and go to state 24
    index                          shift and go to state 25
    matrix_literal                 shift and go to state 30

state 1

    (0) S' -> program .


state 2

    (1) program -> statements .
    (3) statements -> statements . statement
    (4) statement -> . ;
    (5) statement -> . compound_block
    (6) statement -> . compound_stmt
    (7) statement -> . simple_stmt ;
    (27) compound_block -> . { statements }
    (23) compound_stmt -> . FOR ID = range_expr statement
    (24) compound_stmt -> . WHILE ( condition ) statement
    (25) compound_stmt -> . IF ( condition ) statement ELSE statement
    (26) compound_stmt -> . IF ( condition ) statement
    (8) simple_stmt -> . PRINT print_list
    (9) simple_stmt -> . RETURN expr
    (10) simple_stmt -> . CONTINUE
    (11) simple_stmt -> . BREAK
    (12) simple_stmt -> . expr
    (13) simple_stmt -> . assignment
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (16) assignment -> . lvalue DIVASSIGN expr
    (17) assignment -> . lvalue MULASSIGN expr
    (18) assignment -> . lvalue SUBASSIGN expr
    (19) assignment -> . lvalue ADDASSIGN expr
    (20) assignment -> . lvalue = expr
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (14) lvalue -> . index
    (15) lvalue -> . ID
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (46) index -> . ID [ idx_list ]
    (61) matrix_literal -> . [ rows ]
    $end            reduce using rule 1 (program -> statements .)
    ;               shift and go to state 4
    {               shift and go to state 8
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 13
    PRINT           shift and go to state 14
    RETURN          shift and go to state 15
    CONTINUE        shift and go to state 17
    BREAK           shift and go to state 18
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    ID              shift and go to state 10
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    [               shift and go to state 34

    statement                      shift and go to state 35
    compound_block                 shift and go to state 5
    compound_stmt                  shift and go to state 6
    simple_stmt                    shift and go to state 7
    expr                           shift and go to state 16
    assignment                     shift and go to state 19
    term                           shift and go to state 20
    lvalue                         shift and go to state 22
    factor                         shift and go to state 24
    index                          shift and go to state 25
    matrix_literal                 shift and go to state 30

state 3

    (2) statements -> statement .
    ;               reduce using rule 2 (statements -> statement .)
    {               reduce using rule 2 (statements -> statement .)
    FOR             reduce using rule 2 (statements -> statement .)
    WHILE           reduce using rule 2 (statements -> statement .)
    IF              reduce using rule 2 (statements -> statement .)
    PRINT           reduce using rule 2 (statements -> statement .)
    RETURN          reduce using rule 2 (statements -> statement .)
    CONTINUE        reduce using rule 2 (statements -> statement .)
    BREAK           reduce using rule 2 (statements -> statement .)
    NEGATE          reduce using rule 2 (statements -> statement .)
    MINUS           reduce using rule 2 (statements -> statement .)
    ID              reduce using rule 2 (statements -> statement .)
    STRING          reduce using rule 2 (statements -> statement .)
    SCINOTATION     reduce using rule 2 (statements -> statement .)
    FLOATNUM        reduce using rule 2 (statements -> statement .)
    INTNUM          reduce using rule 2 (statements -> statement .)
    (               reduce using rule 2 (statements -> statement .)
    ZEROS           reduce using rule 2 (statements -> statement .)
    EYE             reduce using rule 2 (statements -> statement .)
    ONES            reduce using rule 2 (statements -> statement .)
    [               reduce using rule 2 (statements -> statement .)
    $end            reduce using rule 2 (statements -> statement .)
    }               reduce using rule 2 (statements -> statement .)


state 4

    (4) statement -> ; .
    ;               reduce using rule 4 (statement -> ; .)
    {               reduce using rule 4 (statement -> ; .)
    FOR             reduce using rule 4 (statement -> ; .)
    WHILE           reduce using rule 4 (statement -> ; .)
    IF              reduce using rule 4 (statement -> ; .)
    PRINT           reduce using rule 4 (statement -> ; .)
    RETURN          reduce using rule 4 (statement -> ; .)
    CONTINUE        reduce using rule 4 (statement -> ; .)
    BREAK           reduce using rule 4 (statement -> ; .)
    NEGATE          reduce using rule 4 (statement -> ; .)
    MINUS           reduce using rule 4 (statement -> ; .)
    ID              reduce using rule 4 (statement -> ; .)
    STRING          reduce using rule 4 (statement -> ; .)
    SCINOTATION     reduce using rule 4 (statement -> ; .)
    FLOATNUM        reduce using rule 4 (statement -> ; .)
    INTNUM          reduce using rule 4 (statement -> ; .)
    (               reduce using rule 4 (statement -> ; .)
    ZEROS           reduce using rule 4 (statement -> ; .)
    EYE             reduce using rule 4 (statement -> ; .)
    ONES            reduce using rule 4 (statement -> ; .)
    [               reduce using rule 4 (statement -> ; .)
    $end            reduce using rule 4 (statement -> ; .)
    }               reduce using rule 4 (statement -> ; .)
    ELSE            reduce using rule 4 (statement -> ; .)


state 5

    (5) statement -> compound_block .
    ;               reduce using rule 5 (statement -> compound_block .)
    {               reduce using rule 5 (statement -> compound_block .)
    FOR             reduce using rule 5 (statement -> compound_block .)
    WHILE           reduce using rule 5 (statement -> compound_block .)
    IF              reduce using rule 5 (statement -> compound_block .)
    PRINT           reduce using rule 5 (statement -> compound_block .)
    RETURN          reduce using rule 5 (statement -> compound_block .)
    CONTINUE        reduce using rule 5 (statement -> compound_block .)
    BREAK           reduce using rule 5 (statement -> compound_block .)
    NEGATE          reduce using rule 5 (statement -> compound_block .)
    MINUS           reduce using rule 5 (statement -> compound_block .)
    ID              reduce using rule 5 (statement -> compound_block .)
    STRING          reduce using rule 5 (statement -> compound_block .)
    SCINOTATION     reduce using rule 5 (statement -> compound_block .)
    FLOATNUM        reduce using rule 5 (statement -> compound_block .)
    INTNUM          reduce using rule 5 (statement -> compound_block .)
    (               reduce using rule 5 (statement -> compound_block .)
    ZEROS           reduce using rule 5 (statement -> compound_block .)
    EYE             reduce using rule 5 (statement -> compound_block .)
    ONES            reduce using rule 5 (statement -> compound_block .)
    [               reduce using rule 5 (statement -> compound_block .)
    $end            reduce using rule 5 (statement -> compound_block .)
    }               reduce using rule 5 (statement -> compound_block .)
    ELSE            reduce using rule 5 (statement -> compound_block .)


state 6

    (6) statement -> compound_stmt .
    ;               reduce using rule 6 (statement -> compound_stmt .)
    {               reduce using rule 6 (statement -> compound_stmt .)
    FOR             reduce using rule 6 (statement -> compound_stmt .)
    WHILE           reduce using rule 6 (statement -> compound_stmt .)
    IF              reduce using rule 6 (statement -> compound_stmt .)
    PRINT           reduce using rule 6 (statement -> compound_stmt .)
    RETURN          reduce using rule 6 (statement -> compound_stmt .)
    CONTINUE        reduce using rule 6 (statement -> compound_stmt .)
    BREAK           reduce using rule 6 (statement -> compound_stmt .)
    NEGATE          reduce using rule 6 (statement -> compound_stmt .)
    MINUS           reduce using rule 6 (statement -> compound_stmt .)
    ID              reduce using rule 6 (statement -> compound_stmt .)
    STRING          reduce using rule 6 (statement -> compound_stmt .)
    SCINOTATION     reduce using rule 6 (statement -> compound_stmt .)
    FLOATNUM        reduce using rule 6 (statement -> compound_stmt .)
    INTNUM          reduce using rule 6 (statement -> compound_stmt .)
    (               reduce using rule 6 (statement -> compound_stmt .)
    ZEROS           reduce using rule 6 (statement -> compound_stmt .)
    EYE             reduce using rule 6 (statement -> compound_stmt .)
    ONES            reduce using rule 6 (statement -> compound_stmt .)
    [               reduce using rule 6 (statement -> compound_stmt .)
    $end            reduce using rule 6 (statement -> compound_stmt .)
    }               reduce using rule 6 (statement -> compound_stmt .)
    ELSE            reduce using rule 6 (statement -> compound_stmt .)


state 7

    (7) statement -> simple_stmt . ;
    ;               shift and go to state 36


state 8

    (27) compound_block -> { . statements }
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . ;
    (5) statement -> . compound_block
    (6) statement -> . compound_stmt
    (7) statement -> . simple_stmt ;
    (27) compound_block -> . { statements }
    (23) compound_stmt -> . FOR ID = range_expr statement
    (24) compound_stmt -> . WHILE ( condition ) statement
    (25) compound_stmt -> . IF ( condition ) statement ELSE statement
    (26) compound_stmt -> . IF ( condition ) statement
    (8) simple_stmt -> . PRINT print_list
    (9) simple_stmt -> . RETURN expr
    (10) simple_stmt -> . CONTINUE
    (11) simple_stmt -> . BREAK
    (12) simple_stmt -> . expr
    (13) simple_stmt -> . assignment
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (16) assignment -> . lvalue DIVASSIGN expr
    (17) assignment -> . lvalue MULASSIGN expr
    (18) assignment -> . lvalue SUBASSIGN expr
    (19) assignment -> . lvalue ADDASSIGN expr
    (20) assignment -> . lvalue = expr
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (14) lvalue -> . index
    (15) lvalue -> . ID
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (46) index -> . ID [ idx_list ]
    (61) matrix_literal -> . [ rows ]
    ;               shift and go to state 4
    {               shift and go to state 8
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 13
    PRINT           shift and go to state 14
    RETURN          shift and go to state 15
    CONTINUE        shift and go to state 17
    BREAK           shift and go to state 18
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    ID              shift and go to state 10
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    [               shift and go to state 34

    statements                     shift and go to state 37
    statement                      shift and go to state 3
    compound_block                 shift and go to state 5
    compound_stmt                  shift and go to state 6
    simple_stmt                    shift and go to state 7
    expr                           shift and go to state 16
    assignment                     shift and go to state 19
    term                           shift and go to state 20
    lvalue                         shift and go to state 22
    factor                         shift and go to state 24
    index                          shift and go to state 25
    matrix_literal                 shift and go to state 30

state 9

    (23) compound_stmt -> FOR . ID = range_expr statement
    ID              shift and go to state 38


state 10

    (15) lvalue -> ID .
    (58) factor -> ID .
    (46) index -> ID . [ idx_list ]
    DIVASSIGN       reduce using rule 15 (lvalue -> ID .)
    MULASSIGN       reduce using rule 15 (lvalue -> ID .)
    SUBASSIGN       reduce using rule 15 (lvalue -> ID .)
    ADDASSIGN       reduce using rule 15 (lvalue -> ID .)
    =               reduce using rule 15 (lvalue -> ID .)
    '               reduce using rule 58 (factor -> ID .)
    DOTDIV          reduce using rule 58 (factor -> ID .)
    DOTMUL          reduce using rule 58 (factor -> ID .)
    DIVIDE          reduce using rule 58 (factor -> ID .)
    TIMES           reduce using rule 58 (factor -> ID .)
    DOTSUB          reduce using rule 58 (factor -> ID .)
    DOTADD          reduce using rule 58 (factor -> ID .)
    MINUS           reduce using rule 58 (factor -> ID .)
    PLUS            reduce using rule 58 (factor -> ID .)
    ;               reduce using rule 58 (factor -> ID .)
    [               shift and go to state 39


state 11

    (24) compound_stmt -> WHILE . ( condition ) statement
    (               shift and go to state 40


state 12

    (51) factor -> ( . expr )
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 41
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 13

    (25) compound_stmt -> IF . ( condition ) statement ELSE statement
    (26) compound_stmt -> IF . ( condition ) statement
    (               shift and go to state 44


state 14

    (8) simple_stmt -> PRINT . print_list
    (21) print_list -> . expr
    (22) print_list -> . expr , print_list
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    print_list                     shift and go to state 45
    expr                           shift and go to state 46
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 15

    (9) simple_stmt -> RETURN . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 47
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 16

    (12) simple_stmt -> expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 12 (simple_stmt -> expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 17

    (10) simple_stmt -> CONTINUE .
    ;               reduce using rule 10 (simple_stmt -> CONTINUE .)


state 18

    (11) simple_stmt -> BREAK .
    ;               reduce using rule 11 (simple_stmt -> BREAK .)


state 19

    (13) simple_stmt -> assignment .
    ;               reduce using rule 13 (simple_stmt -> assignment .)


state 20

    (34) expr -> term .
    (42) term -> term . DOTDIV factor
    (43) term -> term . DOTMUL factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . TIMES factor
    DOTSUB          reduce using rule 34 (expr -> term .)
    DOTADD          reduce using rule 34 (expr -> term .)
    MINUS           reduce using rule 34 (expr -> term .)
    PLUS            reduce using rule 34 (expr -> term .)
    ;               reduce using rule 34 (expr -> term .)
    )               reduce using rule 34 (expr -> term .)
    ,               reduce using rule 34 (expr -> term .)
    ]               reduce using rule 34 (expr -> term .)
    GE              reduce using rule 34 (expr -> term .)
    GT              reduce using rule 34 (expr -> term .)
    LE              reduce using rule 34 (expr -> term .)
    LT              reduce using rule 34 (expr -> term .)
    NE              reduce using rule 34 (expr -> term .)
    EQ              reduce using rule 34 (expr -> term .)
    :               reduce using rule 34 (expr -> term .)
    {               reduce using rule 34 (expr -> term .)
    FOR             reduce using rule 34 (expr -> term .)
    WHILE           reduce using rule 34 (expr -> term .)
    IF              reduce using rule 34 (expr -> term .)
    PRINT           reduce using rule 34 (expr -> term .)
    RETURN          reduce using rule 34 (expr -> term .)
    CONTINUE        reduce using rule 34 (expr -> term .)
    BREAK           reduce using rule 34 (expr -> term .)
    NEGATE          reduce using rule 34 (expr -> term .)
    ID              reduce using rule 34 (expr -> term .)
    STRING          reduce using rule 34 (expr -> term .)
    SCINOTATION     reduce using rule 34 (expr -> term .)
    FLOATNUM        reduce using rule 34 (expr -> term .)
    INTNUM          reduce using rule 34 (expr -> term .)
    (               reduce using rule 34 (expr -> term .)
    ZEROS           reduce using rule 34 (expr -> term .)
    EYE             reduce using rule 34 (expr -> term .)
    ONES            reduce using rule 34 (expr -> term .)
    [               reduce using rule 34 (expr -> term .)
    DOTDIV          shift and go to state 52
    DOTMUL          shift and go to state 53
    DIVIDE          shift and go to state 54
    TIMES           shift and go to state 55


state 21

    (40) term -> MINUS . term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    term                           shift and go to state 56
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 22

    (16) assignment -> lvalue . DIVASSIGN expr
    (17) assignment -> lvalue . MULASSIGN expr
    (18) assignment -> lvalue . SUBASSIGN expr
    (19) assignment -> lvalue . ADDASSIGN expr
    (20) assignment -> lvalue . = expr
    DIVASSIGN       shift and go to state 57
    MULASSIGN       shift and go to state 58
    SUBASSIGN       shift and go to state 59
    ADDASSIGN       shift and go to state 60
    =               shift and go to state 61


state 23

    (39) term -> NEGATE . term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    term                           shift and go to state 62
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 24

    (41) term -> factor .
    (56) factor -> factor . '
    DOTDIV          reduce using rule 41 (term -> factor .)
    DOTMUL          reduce using rule 41 (term -> factor .)
    DIVIDE          reduce using rule 41 (term -> factor .)
    TIMES           reduce using rule 41 (term -> factor .)
    DOTSUB          reduce using rule 41 (term -> factor .)
    DOTADD          reduce using rule 41 (term -> factor .)
    MINUS           reduce using rule 41 (term -> factor .)
    PLUS            reduce using rule 41 (term -> factor .)
    ;               reduce using rule 41 (term -> factor .)
    )               reduce using rule 41 (term -> factor .)
    ,               reduce using rule 41 (term -> factor .)
    ]               reduce using rule 41 (term -> factor .)
    GE              reduce using rule 41 (term -> factor .)
    GT              reduce using rule 41 (term -> factor .)
    LE              reduce using rule 41 (term -> factor .)
    LT              reduce using rule 41 (term -> factor .)
    NE              reduce using rule 41 (term -> factor .)
    EQ              reduce using rule 41 (term -> factor .)
    :               reduce using rule 41 (term -> factor .)
    {               reduce using rule 41 (term -> factor .)
    FOR             reduce using rule 41 (term -> factor .)
    WHILE           reduce using rule 41 (term -> factor .)
    IF              reduce using rule 41 (term -> factor .)
    PRINT           reduce using rule 41 (term -> factor .)
    RETURN          reduce using rule 41 (term -> factor .)
    CONTINUE        reduce using rule 41 (term -> factor .)
    BREAK           reduce using rule 41 (term -> factor .)
    NEGATE          reduce using rule 41 (term -> factor .)
    ID              reduce using rule 41 (term -> factor .)
    STRING          reduce using rule 41 (term -> factor .)
    SCINOTATION     reduce using rule 41 (term -> factor .)
    FLOATNUM        reduce using rule 41 (term -> factor .)
    INTNUM          reduce using rule 41 (term -> factor .)
    (               reduce using rule 41 (term -> factor .)
    ZEROS           reduce using rule 41 (term -> factor .)
    EYE             reduce using rule 41 (term -> factor .)
    ONES            reduce using rule 41 (term -> factor .)
    [               reduce using rule 41 (term -> factor .)
    '               shift and go to state 63


state 25

    (14) lvalue -> index .
    (57) factor -> index .
    DIVASSIGN       reduce using rule 14 (lvalue -> index .)
    MULASSIGN       reduce using rule 14 (lvalue -> index .)
    SUBASSIGN       reduce using rule 14 (lvalue -> index .)
    ADDASSIGN       reduce using rule 14 (lvalue -> index .)
    =               reduce using rule 14 (lvalue -> index .)
    '               reduce using rule 57 (factor -> index .)
    DOTDIV          reduce using rule 57 (factor -> index .)
    DOTMUL          reduce using rule 57 (factor -> index .)
    DIVIDE          reduce using rule 57 (factor -> index .)
    TIMES           reduce using rule 57 (factor -> index .)
    DOTSUB          reduce using rule 57 (factor -> index .)
    DOTADD          reduce using rule 57 (factor -> index .)
    MINUS           reduce using rule 57 (factor -> index .)
    PLUS            reduce using rule 57 (factor -> index .)
    ;               reduce using rule 57 (factor -> index .)


state 26

    (47) factor -> STRING .
    '               reduce using rule 47 (factor -> STRING .)
    DOTDIV          reduce using rule 47 (factor -> STRING .)
    DOTMUL          reduce using rule 47 (factor -> STRING .)
    DIVIDE          reduce using rule 47 (factor -> STRING .)
    TIMES           reduce using rule 47 (factor -> STRING .)
    DOTSUB          reduce using rule 47 (factor -> STRING .)
    DOTADD          reduce using rule 47 (factor -> STRING .)
    MINUS           reduce using rule 47 (factor -> STRING .)
    PLUS            reduce using rule 47 (factor -> STRING .)
    ;               reduce using rule 47 (factor -> STRING .)
    )               reduce using rule 47 (factor -> STRING .)
    ,               reduce using rule 47 (factor -> STRING .)
    ]               reduce using rule 47 (factor -> STRING .)
    GE              reduce using rule 47 (factor -> STRING .)
    GT              reduce using rule 47 (factor -> STRING .)
    LE              reduce using rule 47 (factor -> STRING .)
    LT              reduce using rule 47 (factor -> STRING .)
    NE              reduce using rule 47 (factor -> STRING .)
    EQ              reduce using rule 47 (factor -> STRING .)
    :               reduce using rule 47 (factor -> STRING .)
    {               reduce using rule 47 (factor -> STRING .)
    FOR             reduce using rule 47 (factor -> STRING .)
    WHILE           reduce using rule 47 (factor -> STRING .)
    IF              reduce using rule 47 (factor -> STRING .)
    PRINT           reduce using rule 47 (factor -> STRING .)
    RETURN          reduce using rule 47 (factor -> STRING .)
    CONTINUE        reduce using rule 47 (factor -> STRING .)
    BREAK           reduce using rule 47 (factor -> STRING .)
    NEGATE          reduce using rule 47 (factor -> STRING .)
    ID              reduce using rule 47 (factor -> STRING .)
    STRING          reduce using rule 47 (factor -> STRING .)
    SCINOTATION     reduce using rule 47 (factor -> STRING .)
    FLOATNUM        reduce using rule 47 (factor -> STRING .)
    INTNUM          reduce using rule 47 (factor -> STRING .)
    (               reduce using rule 47 (factor -> STRING .)
    ZEROS           reduce using rule 47 (factor -> STRING .)
    EYE             reduce using rule 47 (factor -> STRING .)
    ONES            reduce using rule 47 (factor -> STRING .)
    [               reduce using rule 47 (factor -> STRING .)


state 27

    (48) factor -> SCINOTATION .
    '               reduce using rule 48 (factor -> SCINOTATION .)
    DOTDIV          reduce using rule 48 (factor -> SCINOTATION .)
    DOTMUL          reduce using rule 48 (factor -> SCINOTATION .)
    DIVIDE          reduce using rule 48 (factor -> SCINOTATION .)
    TIMES           reduce using rule 48 (factor -> SCINOTATION .)
    DOTSUB          reduce using rule 48 (factor -> SCINOTATION .)
    DOTADD          reduce using rule 48 (factor -> SCINOTATION .)
    MINUS           reduce using rule 48 (factor -> SCINOTATION .)
    PLUS            reduce using rule 48 (factor -> SCINOTATION .)
    ;               reduce using rule 48 (factor -> SCINOTATION .)
    )               reduce using rule 48 (factor -> SCINOTATION .)
    ,               reduce using rule 48 (factor -> SCINOTATION .)
    ]               reduce using rule 48 (factor -> SCINOTATION .)
    GE              reduce using rule 48 (factor -> SCINOTATION .)
    GT              reduce using rule 48 (factor -> SCINOTATION .)
    LE              reduce using rule 48 (factor -> SCINOTATION .)
    LT              reduce using rule 48 (factor -> SCINOTATION .)
    NE              reduce using rule 48 (factor -> SCINOTATION .)
    EQ              reduce using rule 48 (factor -> SCINOTATION .)
    :               reduce using rule 48 (factor -> SCINOTATION .)
    {               reduce using rule 48 (factor -> SCINOTATION .)
    FOR             reduce using rule 48 (factor -> SCINOTATION .)
    WHILE           reduce using rule 48 (factor -> SCINOTATION .)
    IF              reduce using rule 48 (factor -> SCINOTATION .)
    PRINT           reduce using rule 48 (factor -> SCINOTATION .)
    RETURN          reduce using rule 48 (factor -> SCINOTATION .)
    CONTINUE        reduce using rule 48 (factor -> SCINOTATION .)
    BREAK           reduce using rule 48 (factor -> SCINOTATION .)
    NEGATE          reduce using rule 48 (factor -> SCINOTATION .)
    ID              reduce using rule 48 (factor -> SCINOTATION .)
    STRING          reduce using rule 48 (factor -> SCINOTATION .)
    SCINOTATION     reduce using rule 48 (factor -> SCINOTATION .)
    FLOATNUM        reduce using rule 48 (factor -> SCINOTATION .)
    INTNUM          reduce using rule 48 (factor -> SCINOTATION .)
    (               reduce using rule 48 (factor -> SCINOTATION .)
    ZEROS           reduce using rule 48 (factor -> SCINOTATION .)
    EYE             reduce using rule 48 (factor -> SCINOTATION .)
    ONES            reduce using rule 48 (factor -> SCINOTATION .)
    [               reduce using rule 48 (factor -> SCINOTATION .)


state 28

    (49) factor -> FLOATNUM .
    '               reduce using rule 49 (factor -> FLOATNUM .)
    DOTDIV          reduce using rule 49 (factor -> FLOATNUM .)
    DOTMUL          reduce using rule 49 (factor -> FLOATNUM .)
    DIVIDE          reduce using rule 49 (factor -> FLOATNUM .)
    TIMES           reduce using rule 49 (factor -> FLOATNUM .)
    DOTSUB          reduce using rule 49 (factor -> FLOATNUM .)
    DOTADD          reduce using rule 49 (factor -> FLOATNUM .)
    MINUS           reduce using rule 49 (factor -> FLOATNUM .)
    PLUS            reduce using rule 49 (factor -> FLOATNUM .)
    ;               reduce using rule 49 (factor -> FLOATNUM .)
    )               reduce using rule 49 (factor -> FLOATNUM .)
    ,               reduce using rule 49 (factor -> FLOATNUM .)
    ]               reduce using rule 49 (factor -> FLOATNUM .)
    GE              reduce using rule 49 (factor -> FLOATNUM .)
    GT              reduce using rule 49 (factor -> FLOATNUM .)
    LE              reduce using rule 49 (factor -> FLOATNUM .)
    LT              reduce using rule 49 (factor -> FLOATNUM .)
    NE              reduce using rule 49 (factor -> FLOATNUM .)
    EQ              reduce using rule 49 (factor -> FLOATNUM .)
    :               reduce using rule 49 (factor -> FLOATNUM .)
    {               reduce using rule 49 (factor -> FLOATNUM .)
    FOR             reduce using rule 49 (factor -> FLOATNUM .)
    WHILE           reduce using rule 49 (factor -> FLOATNUM .)
    IF              reduce using rule 49 (factor -> FLOATNUM .)
    PRINT           reduce using rule 49 (factor -> FLOATNUM .)
    RETURN          reduce using rule 49 (factor -> FLOATNUM .)
    CONTINUE        reduce using rule 49 (factor -> FLOATNUM .)
    BREAK           reduce using rule 49 (factor -> FLOATNUM .)
    NEGATE          reduce using rule 49 (factor -> FLOATNUM .)
    ID              reduce using rule 49 (factor -> FLOATNUM .)
    STRING          reduce using rule 49 (factor -> FLOATNUM .)
    SCINOTATION     reduce using rule 49 (factor -> FLOATNUM .)
    FLOATNUM        reduce using rule 49 (factor -> FLOATNUM .)
    INTNUM          reduce using rule 49 (factor -> FLOATNUM .)
    (               reduce using rule 49 (factor -> FLOATNUM .)
    ZEROS           reduce using rule 49 (factor -> FLOATNUM .)
    EYE             reduce using rule 49 (factor -> FLOATNUM .)
    ONES            reduce using rule 49 (factor -> FLOATNUM .)
    [               reduce using rule 49 (factor -> FLOATNUM .)


state 29

    (50) factor -> INTNUM .
    '               reduce using rule 50 (factor -> INTNUM .)
    DOTDIV          reduce using rule 50 (factor -> INTNUM .)
    DOTMUL          reduce using rule 50 (factor -> INTNUM .)
    DIVIDE          reduce using rule 50 (factor -> INTNUM .)
    TIMES           reduce using rule 50 (factor -> INTNUM .)
    DOTSUB          reduce using rule 50 (factor -> INTNUM .)
    DOTADD          reduce using rule 50 (factor -> INTNUM .)
    MINUS           reduce using rule 50 (factor -> INTNUM .)
    PLUS            reduce using rule 50 (factor -> INTNUM .)
    ;               reduce using rule 50 (factor -> INTNUM .)
    )               reduce using rule 50 (factor -> INTNUM .)
    ,               reduce using rule 50 (factor -> INTNUM .)
    ]               reduce using rule 50 (factor -> INTNUM .)
    GE              reduce using rule 50 (factor -> INTNUM .)
    GT              reduce using rule 50 (factor -> INTNUM .)
    LE              reduce using rule 50 (factor -> INTNUM .)
    LT              reduce using rule 50 (factor -> INTNUM .)
    NE              reduce using rule 50 (factor -> INTNUM .)
    EQ              reduce using rule 50 (factor -> INTNUM .)
    :               reduce using rule 50 (factor -> INTNUM .)
    {               reduce using rule 50 (factor -> INTNUM .)
    FOR             reduce using rule 50 (factor -> INTNUM .)
    WHILE           reduce using rule 50 (factor -> INTNUM .)
    IF              reduce using rule 50 (factor -> INTNUM .)
    PRINT           reduce using rule 50 (factor -> INTNUM .)
    RETURN          reduce using rule 50 (factor -> INTNUM .)
    CONTINUE        reduce using rule 50 (factor -> INTNUM .)
    BREAK           reduce using rule 50 (factor -> INTNUM .)
    NEGATE          reduce using rule 50 (factor -> INTNUM .)
    ID              reduce using rule 50 (factor -> INTNUM .)
    STRING          reduce using rule 50 (factor -> INTNUM .)
    SCINOTATION     reduce using rule 50 (factor -> INTNUM .)
    FLOATNUM        reduce using rule 50 (factor -> INTNUM .)
    INTNUM          reduce using rule 50 (factor -> INTNUM .)
    (               reduce using rule 50 (factor -> INTNUM .)
    ZEROS           reduce using rule 50 (factor -> INTNUM .)
    EYE             reduce using rule 50 (factor -> INTNUM .)
    ONES            reduce using rule 50 (factor -> INTNUM .)
    [               reduce using rule 50 (factor -> INTNUM .)


state 30

    (52) factor -> matrix_literal .
    '               reduce using rule 52 (factor -> matrix_literal .)
    DOTDIV          reduce using rule 52 (factor -> matrix_literal .)
    DOTMUL          reduce using rule 52 (factor -> matrix_literal .)
    DIVIDE          reduce using rule 52 (factor -> matrix_literal .)
    TIMES           reduce using rule 52 (factor -> matrix_literal .)
    DOTSUB          reduce using rule 52 (factor -> matrix_literal .)
    DOTADD          reduce using rule 52 (factor -> matrix_literal .)
    MINUS           reduce using rule 52 (factor -> matrix_literal .)
    PLUS            reduce using rule 52 (factor -> matrix_literal .)
    ;               reduce using rule 52 (factor -> matrix_literal .)
    )               reduce using rule 52 (factor -> matrix_literal .)
    ,               reduce using rule 52 (factor -> matrix_literal .)
    ]               reduce using rule 52 (factor -> matrix_literal .)
    GE              reduce using rule 52 (factor -> matrix_literal .)
    GT              reduce using rule 52 (factor -> matrix_literal .)
    LE              reduce using rule 52 (factor -> matrix_literal .)
    LT              reduce using rule 52 (factor -> matrix_literal .)
    NE              reduce using rule 52 (factor -> matrix_literal .)
    EQ              reduce using rule 52 (factor -> matrix_literal .)
    :               reduce using rule 52 (factor -> matrix_literal .)
    {               reduce using rule 52 (factor -> matrix_literal .)
    FOR             reduce using rule 52 (factor -> matrix_literal .)
    WHILE           reduce using rule 52 (factor -> matrix_literal .)
    IF              reduce using rule 52 (factor -> matrix_literal .)
    PRINT           reduce using rule 52 (factor -> matrix_literal .)
    RETURN          reduce using rule 52 (factor -> matrix_literal .)
    CONTINUE        reduce using rule 52 (factor -> matrix_literal .)
    BREAK           reduce using rule 52 (factor -> matrix_literal .)
    NEGATE          reduce using rule 52 (factor -> matrix_literal .)
    ID              reduce using rule 52 (factor -> matrix_literal .)
    STRING          reduce using rule 52 (factor -> matrix_literal .)
    SCINOTATION     reduce using rule 52 (factor -> matrix_literal .)
    FLOATNUM        reduce using rule 52 (factor -> matrix_literal .)
    INTNUM          reduce using rule 52 (factor -> matrix_literal .)
    (               reduce using rule 52 (factor -> matrix_literal .)
    ZEROS           reduce using rule 52 (factor -> matrix_literal .)
    EYE             reduce using rule 52 (factor -> matrix_literal .)
    ONES            reduce using rule 52 (factor -> matrix_literal .)
    [               reduce using rule 52 (factor -> matrix_literal .)


state 31

    (53) factor -> ZEROS . ( idx_list )
    (               shift and go to state 64


state 32

    (54) factor -> EYE . ( idx_list )
    (               shift and go to state 65


state 33

    (55) factor -> ONES . ( idx_list )
    (               shift and go to state 66


state 34

    (61) matrix_literal -> [ . rows ]
    (62) rows -> . rows ; row
    (63) rows -> . row
    (64) row -> . elements
    (65) elements -> . elements , expr
    (66) elements -> . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    rows                           shift and go to state 67
    row                            shift and go to state 68
    elements                       shift and go to state 69
    expr                           shift and go to state 70
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 35

    (3) statements -> statements statement .
    ;               reduce using rule 3 (statements -> statements statement .)
    {               reduce using rule 3 (statements -> statements statement .)
    FOR             reduce using rule 3 (statements -> statements statement .)
    WHILE           reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    PRINT           reduce using rule 3 (statements -> statements statement .)
    RETURN          reduce using rule 3 (statements -> statements statement .)
    CONTINUE        reduce using rule 3 (statements -> statements statement .)
    BREAK           reduce using rule 3 (statements -> statements statement .)
    NEGATE          reduce using rule 3 (statements -> statements statement .)
    MINUS           reduce using rule 3 (statements -> statements statement .)
    ID              reduce using rule 3 (statements -> statements statement .)
    STRING          reduce using rule 3 (statements -> statements statement .)
    SCINOTATION     reduce using rule 3 (statements -> statements statement .)
    FLOATNUM        reduce using rule 3 (statements -> statements statement .)
    INTNUM          reduce using rule 3 (statements -> statements statement .)
    (               reduce using rule 3 (statements -> statements statement .)
    ZEROS           reduce using rule 3 (statements -> statements statement .)
    EYE             reduce using rule 3 (statements -> statements statement .)
    ONES            reduce using rule 3 (statements -> statements statement .)
    [               reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    }               reduce using rule 3 (statements -> statements statement .)


state 36

    (7) statement -> simple_stmt ; .
    ;               reduce using rule 7 (statement -> simple_stmt ; .)
    {               reduce using rule 7 (statement -> simple_stmt ; .)
    FOR             reduce using rule 7 (statement -> simple_stmt ; .)
    WHILE           reduce using rule 7 (statement -> simple_stmt ; .)
    IF              reduce using rule 7 (statement -> simple_stmt ; .)
    PRINT           reduce using rule 7 (statement -> simple_stmt ; .)
    RETURN          reduce using rule 7 (statement -> simple_stmt ; .)
    CONTINUE        reduce using rule 7 (statement -> simple_stmt ; .)
    BREAK           reduce using rule 7 (statement -> simple_stmt ; .)
    NEGATE          reduce using rule 7 (statement -> simple_stmt ; .)
    MINUS           reduce using rule 7 (statement -> simple_stmt ; .)
    ID              reduce using rule 7 (statement -> simple_stmt ; .)
    STRING          reduce using rule 7 (statement -> simple_stmt ; .)
    SCINOTATION     reduce using rule 7 (statement -> simple_stmt ; .)
    FLOATNUM        reduce using rule 7 (statement -> simple_stmt ; .)
    INTNUM          reduce using rule 7 (statement -> simple_stmt ; .)
    (               reduce using rule 7 (statement -> simple_stmt ; .)
    ZEROS           reduce using rule 7 (statement -> simple_stmt ; .)
    EYE             reduce using rule 7 (statement -> simple_stmt ; .)
    ONES            reduce using rule 7 (statement -> simple_stmt ; .)
    [               reduce using rule 7 (statement -> simple_stmt ; .)
    $end            reduce using rule 7 (statement -> simple_stmt ; .)
    }               reduce using rule 7 (statement -> simple_stmt ; .)
    ELSE            reduce using rule 7 (statement -> simple_stmt ; .)


state 37

    (27) compound_block -> { statements . }
    (3) statements -> statements . statement
    (4) statement -> . ;
    (5) statement -> . compound_block
    (6) statement -> . compound_stmt
    (7) statement -> . simple_stmt ;
    (27) compound_block -> . { statements }
    (23) compound_stmt -> . FOR ID = range_expr statement
    (24) compound_stmt -> . WHILE ( condition ) statement
    (25) compound_stmt -> . IF ( condition ) statement ELSE statement
    (26) compound_stmt -> . IF ( condition ) statement
    (8) simple_stmt -> . PRINT print_list
    (9) simple_stmt -> . RETURN expr
    (10) simple_stmt -> . CONTINUE
    (11) simple_stmt -> . BREAK
    (12) simple_stmt -> . expr
    (13) simple_stmt -> . assignment
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (16) assignment -> . lvalue DIVASSIGN expr
    (17) assignment -> . lvalue MULASSIGN expr
    (18) assignment -> . lvalue SUBASSIGN expr
    (19) assignment -> . lvalue ADDASSIGN expr
    (20) assignment -> . lvalue = expr
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (14) lvalue -> . index
    (15) lvalue -> . ID
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (46) index -> . ID [ idx_list ]
    (61) matrix_literal -> . [ rows ]
    }               shift and go to state 71
    ;               shift and go to state 4
    {               shift and go to state 8
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 13
    PRINT           shift and go to state 14
    RETURN          shift and go to state 15
    CONTINUE        shift and go to state 17
    BREAK           shift and go to state 18
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    ID              shift and go to state 10
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    [               shift and go to state 34

    statement                      shift and go to state 35
    compound_block                 shift and go to state 5
    compound_stmt                  shift and go to state 6
    simple_stmt                    shift and go to state 7
    expr                           shift and go to state 16
    assignment                     shift and go to state 19
    term                           shift and go to state 20
    lvalue                         shift and go to state 22
    factor                         shift and go to state 24
    index                          shift and go to state 25
    matrix_literal                 shift and go to state 30

state 38

    (23) compound_stmt -> FOR ID . = range_expr statement
    =               shift and go to state 72


state 39

    (46) index -> ID [ . idx_list ]
    (59) idx_list -> . idx_list , INTNUM
    (60) idx_list -> . INTNUM
    INTNUM          shift and go to state 74

    idx_list                       shift and go to state 73

state 40

    (24) compound_stmt -> WHILE ( . condition ) statement
    (28) condition -> . expr GE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LE expr
    (31) condition -> . expr LT expr
    (32) condition -> . expr NE expr
    (33) condition -> . expr EQ expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    condition                      shift and go to state 75
    expr                           shift and go to state 76
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 41

    (51) factor -> ( expr . )
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    )               shift and go to state 77
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 42

    (57) factor -> index .
    '               reduce using rule 57 (factor -> index .)
    DOTDIV          reduce using rule 57 (factor -> index .)
    DOTMUL          reduce using rule 57 (factor -> index .)
    DIVIDE          reduce using rule 57 (factor -> index .)
    TIMES           reduce using rule 57 (factor -> index .)
    )               reduce using rule 57 (factor -> index .)
    DOTSUB          reduce using rule 57 (factor -> index .)
    DOTADD          reduce using rule 57 (factor -> index .)
    MINUS           reduce using rule 57 (factor -> index .)
    PLUS            reduce using rule 57 (factor -> index .)
    ,               reduce using rule 57 (factor -> index .)
    ;               reduce using rule 57 (factor -> index .)
    ]               reduce using rule 57 (factor -> index .)
    GE              reduce using rule 57 (factor -> index .)
    GT              reduce using rule 57 (factor -> index .)
    LE              reduce using rule 57 (factor -> index .)
    LT              reduce using rule 57 (factor -> index .)
    NE              reduce using rule 57 (factor -> index .)
    EQ              reduce using rule 57 (factor -> index .)
    :               reduce using rule 57 (factor -> index .)
    {               reduce using rule 57 (factor -> index .)
    FOR             reduce using rule 57 (factor -> index .)
    WHILE           reduce using rule 57 (factor -> index .)
    IF              reduce using rule 57 (factor -> index .)
    PRINT           reduce using rule 57 (factor -> index .)
    RETURN          reduce using rule 57 (factor -> index .)
    CONTINUE        reduce using rule 57 (factor -> index .)
    BREAK           reduce using rule 57 (factor -> index .)
    NEGATE          reduce using rule 57 (factor -> index .)
    ID              reduce using rule 57 (factor -> index .)
    STRING          reduce using rule 57 (factor -> index .)
    SCINOTATION     reduce using rule 57 (factor -> index .)
    FLOATNUM        reduce using rule 57 (factor -> index .)
    INTNUM          reduce using rule 57 (factor -> index .)
    (               reduce using rule 57 (factor -> index .)
    ZEROS           reduce using rule 57 (factor -> index .)
    EYE             reduce using rule 57 (factor -> index .)
    ONES            reduce using rule 57 (factor -> index .)
    [               reduce using rule 57 (factor -> index .)


state 43

    (58) factor -> ID .
    (46) index -> ID . [ idx_list ]
  ! shift/reduce conflict for [ resolved as shift
    '               reduce using rule 58 (factor -> ID .)
    DOTDIV          reduce using rule 58 (factor -> ID .)
    DOTMUL          reduce using rule 58 (factor -> ID .)
    DIVIDE          reduce using rule 58 (factor -> ID .)
    TIMES           reduce using rule 58 (factor -> ID .)
    )               reduce using rule 58 (factor -> ID .)
    DOTSUB          reduce using rule 58 (factor -> ID .)
    DOTADD          reduce using rule 58 (factor -> ID .)
    MINUS           reduce using rule 58 (factor -> ID .)
    PLUS            reduce using rule 58 (factor -> ID .)
    ,               reduce using rule 58 (factor -> ID .)
    ;               reduce using rule 58 (factor -> ID .)
    ]               reduce using rule 58 (factor -> ID .)
    GE              reduce using rule 58 (factor -> ID .)
    GT              reduce using rule 58 (factor -> ID .)
    LE              reduce using rule 58 (factor -> ID .)
    LT              reduce using rule 58 (factor -> ID .)
    NE              reduce using rule 58 (factor -> ID .)
    EQ              reduce using rule 58 (factor -> ID .)
    :               reduce using rule 58 (factor -> ID .)
    {               reduce using rule 58 (factor -> ID .)
    FOR             reduce using rule 58 (factor -> ID .)
    WHILE           reduce using rule 58 (factor -> ID .)
    IF              reduce using rule 58 (factor -> ID .)
    PRINT           reduce using rule 58 (factor -> ID .)
    RETURN          reduce using rule 58 (factor -> ID .)
    CONTINUE        reduce using rule 58 (factor -> ID .)
    BREAK           reduce using rule 58 (factor -> ID .)
    NEGATE          reduce using rule 58 (factor -> ID .)
    ID              reduce using rule 58 (factor -> ID .)
    STRING          reduce using rule 58 (factor -> ID .)
    SCINOTATION     reduce using rule 58 (factor -> ID .)
    FLOATNUM        reduce using rule 58 (factor -> ID .)
    INTNUM          reduce using rule 58 (factor -> ID .)
    (               reduce using rule 58 (factor -> ID .)
    ZEROS           reduce using rule 58 (factor -> ID .)
    EYE             reduce using rule 58 (factor -> ID .)
    ONES            reduce using rule 58 (factor -> ID .)
    [               shift and go to state 39


state 44

    (25) compound_stmt -> IF ( . condition ) statement ELSE statement
    (26) compound_stmt -> IF ( . condition ) statement
    (28) condition -> . expr GE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LE expr
    (31) condition -> . expr LT expr
    (32) condition -> . expr NE expr
    (33) condition -> . expr EQ expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    condition                      shift and go to state 78
    expr                           shift and go to state 76
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 45

    (8) simple_stmt -> PRINT print_list .
    ;               reduce using rule 8 (simple_stmt -> PRINT print_list .)


state 46

    (21) print_list -> expr .
    (22) print_list -> expr . , print_list
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 21 (print_list -> expr .)
    ,               shift and go to state 79
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 47

    (9) simple_stmt -> RETURN expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 9 (simple_stmt -> RETURN expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 48

    (35) expr -> expr DOTSUB . term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    term                           shift and go to state 80
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 49

    (36) expr -> expr DOTADD . term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    term                           shift and go to state 81
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 50

    (37) expr -> expr MINUS . term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    term                           shift and go to state 82
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 51

    (38) expr -> expr PLUS . term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    term                           shift and go to state 83
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 52

    (42) term -> term DOTDIV . factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    factor                         shift and go to state 84
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 53

    (43) term -> term DOTMUL . factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    factor                         shift and go to state 85
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 54

    (44) term -> term DIVIDE . factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    factor                         shift and go to state 86
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 55

    (45) term -> term TIMES . factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    factor                         shift and go to state 87
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 56

    (40) term -> MINUS term .
    (42) term -> term . DOTDIV factor
    (43) term -> term . DOTMUL factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . TIMES factor
    DOTDIV          reduce using rule 40 (term -> MINUS term .)
    DOTMUL          reduce using rule 40 (term -> MINUS term .)
    DIVIDE          reduce using rule 40 (term -> MINUS term .)
    TIMES           reduce using rule 40 (term -> MINUS term .)
    DOTSUB          reduce using rule 40 (term -> MINUS term .)
    DOTADD          reduce using rule 40 (term -> MINUS term .)
    MINUS           reduce using rule 40 (term -> MINUS term .)
    PLUS            reduce using rule 40 (term -> MINUS term .)
    ;               reduce using rule 40 (term -> MINUS term .)
    )               reduce using rule 40 (term -> MINUS term .)
    ,               reduce using rule 40 (term -> MINUS term .)
    ]               reduce using rule 40 (term -> MINUS term .)
    GE              reduce using rule 40 (term -> MINUS term .)
    GT              reduce using rule 40 (term -> MINUS term .)
    LE              reduce using rule 40 (term -> MINUS term .)
    LT              reduce using rule 40 (term -> MINUS term .)
    NE              reduce using rule 40 (term -> MINUS term .)
    EQ              reduce using rule 40 (term -> MINUS term .)
    :               reduce using rule 40 (term -> MINUS term .)
    {               reduce using rule 40 (term -> MINUS term .)
    FOR             reduce using rule 40 (term -> MINUS term .)
    WHILE           reduce using rule 40 (term -> MINUS term .)
    IF              reduce using rule 40 (term -> MINUS term .)
    PRINT           reduce using rule 40 (term -> MINUS term .)
    RETURN          reduce using rule 40 (term -> MINUS term .)
    CONTINUE        reduce using rule 40 (term -> MINUS term .)
    BREAK           reduce using rule 40 (term -> MINUS term .)
    NEGATE          reduce using rule 40 (term -> MINUS term .)
    ID              reduce using rule 40 (term -> MINUS term .)
    STRING          reduce using rule 40 (term -> MINUS term .)
    SCINOTATION     reduce using rule 40 (term -> MINUS term .)
    FLOATNUM        reduce using rule 40 (term -> MINUS term .)
    INTNUM          reduce using rule 40 (term -> MINUS term .)
    (               reduce using rule 40 (term -> MINUS term .)
    ZEROS           reduce using rule 40 (term -> MINUS term .)
    EYE             reduce using rule 40 (term -> MINUS term .)
    ONES            reduce using rule 40 (term -> MINUS term .)
    [               reduce using rule 40 (term -> MINUS term .)


state 57

    (16) assignment -> lvalue DIVASSIGN . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 88
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 58

    (17) assignment -> lvalue MULASSIGN . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 89
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 59

    (18) assignment -> lvalue SUBASSIGN . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 90
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 60

    (19) assignment -> lvalue ADDASSIGN . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 91
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 61

    (20) assignment -> lvalue = . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 92
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 62

    (39) term -> NEGATE term .
    (42) term -> term . DOTDIV factor
    (43) term -> term . DOTMUL factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . TIMES factor
    DOTDIV          reduce using rule 39 (term -> NEGATE term .)
    DOTMUL          reduce using rule 39 (term -> NEGATE term .)
    DIVIDE          reduce using rule 39 (term -> NEGATE term .)
    TIMES           reduce using rule 39 (term -> NEGATE term .)
    DOTSUB          reduce using rule 39 (term -> NEGATE term .)
    DOTADD          reduce using rule 39 (term -> NEGATE term .)
    MINUS           reduce using rule 39 (term -> NEGATE term .)
    PLUS            reduce using rule 39 (term -> NEGATE term .)
    ;               reduce using rule 39 (term -> NEGATE term .)
    )               reduce using rule 39 (term -> NEGATE term .)
    ,               reduce using rule 39 (term -> NEGATE term .)
    ]               reduce using rule 39 (term -> NEGATE term .)
    GE              reduce using rule 39 (term -> NEGATE term .)
    GT              reduce using rule 39 (term -> NEGATE term .)
    LE              reduce using rule 39 (term -> NEGATE term .)
    LT              reduce using rule 39 (term -> NEGATE term .)
    NE              reduce using rule 39 (term -> NEGATE term .)
    EQ              reduce using rule 39 (term -> NEGATE term .)
    :               reduce using rule 39 (term -> NEGATE term .)
    {               reduce using rule 39 (term -> NEGATE term .)
    FOR             reduce using rule 39 (term -> NEGATE term .)
    WHILE           reduce using rule 39 (term -> NEGATE term .)
    IF              reduce using rule 39 (term -> NEGATE term .)
    PRINT           reduce using rule 39 (term -> NEGATE term .)
    RETURN          reduce using rule 39 (term -> NEGATE term .)
    CONTINUE        reduce using rule 39 (term -> NEGATE term .)
    BREAK           reduce using rule 39 (term -> NEGATE term .)
    NEGATE          reduce using rule 39 (term -> NEGATE term .)
    ID              reduce using rule 39 (term -> NEGATE term .)
    STRING          reduce using rule 39 (term -> NEGATE term .)
    SCINOTATION     reduce using rule 39 (term -> NEGATE term .)
    FLOATNUM        reduce using rule 39 (term -> NEGATE term .)
    INTNUM          reduce using rule 39 (term -> NEGATE term .)
    (               reduce using rule 39 (term -> NEGATE term .)
    ZEROS           reduce using rule 39 (term -> NEGATE term .)
    EYE             reduce using rule 39 (term -> NEGATE term .)
    ONES            reduce using rule 39 (term -> NEGATE term .)
    [               reduce using rule 39 (term -> NEGATE term .)


state 63

    (56) factor -> factor ' .
    '               reduce using rule 56 (factor -> factor ' .)
    DOTDIV          reduce using rule 56 (factor -> factor ' .)
    DOTMUL          reduce using rule 56 (factor -> factor ' .)
    DIVIDE          reduce using rule 56 (factor -> factor ' .)
    TIMES           reduce using rule 56 (factor -> factor ' .)
    DOTSUB          reduce using rule 56 (factor -> factor ' .)
    DOTADD          reduce using rule 56 (factor -> factor ' .)
    MINUS           reduce using rule 56 (factor -> factor ' .)
    PLUS            reduce using rule 56 (factor -> factor ' .)
    ;               reduce using rule 56 (factor -> factor ' .)
    )               reduce using rule 56 (factor -> factor ' .)
    ,               reduce using rule 56 (factor -> factor ' .)
    ]               reduce using rule 56 (factor -> factor ' .)
    GE              reduce using rule 56 (factor -> factor ' .)
    GT              reduce using rule 56 (factor -> factor ' .)
    LE              reduce using rule 56 (factor -> factor ' .)
    LT              reduce using rule 56 (factor -> factor ' .)
    NE              reduce using rule 56 (factor -> factor ' .)
    EQ              reduce using rule 56 (factor -> factor ' .)
    :               reduce using rule 56 (factor -> factor ' .)
    {               reduce using rule 56 (factor -> factor ' .)
    FOR             reduce using rule 56 (factor -> factor ' .)
    WHILE           reduce using rule 56 (factor -> factor ' .)
    IF              reduce using rule 56 (factor -> factor ' .)
    PRINT           reduce using rule 56 (factor -> factor ' .)
    RETURN          reduce using rule 56 (factor -> factor ' .)
    CONTINUE        reduce using rule 56 (factor -> factor ' .)
    BREAK           reduce using rule 56 (factor -> factor ' .)
    NEGATE          reduce using rule 56 (factor -> factor ' .)
    ID              reduce using rule 56 (factor -> factor ' .)
    STRING          reduce using rule 56 (factor -> factor ' .)
    SCINOTATION     reduce using rule 56 (factor -> factor ' .)
    FLOATNUM        reduce using rule 56 (factor -> factor ' .)
    INTNUM          reduce using rule 56 (factor -> factor ' .)
    (               reduce using rule 56 (factor -> factor ' .)
    ZEROS           reduce using rule 56 (factor -> factor ' .)
    EYE             reduce using rule 56 (factor -> factor ' .)
    ONES            reduce using rule 56 (factor -> factor ' .)
    [               reduce using rule 56 (factor -> factor ' .)


state 64

    (53) factor -> ZEROS ( . idx_list )
    (59) idx_list -> . idx_list , INTNUM
    (60) idx_list -> . INTNUM
    INTNUM          shift and go to state 74

    idx_list                       shift and go to state 93

state 65

    (54) factor -> EYE ( . idx_list )
    (59) idx_list -> . idx_list , INTNUM
    (60) idx_list -> . INTNUM
    INTNUM          shift and go to state 74

    idx_list                       shift and go to state 94

state 66

    (55) factor -> ONES ( . idx_list )
    (59) idx_list -> . idx_list , INTNUM
    (60) idx_list -> . INTNUM
    INTNUM          shift and go to state 74

    idx_list                       shift and go to state 95

state 67

    (61) matrix_literal -> [ rows . ]
    (62) rows -> rows . ; row
    ]               shift and go to state 96
    ;               shift and go to state 97


state 68

    (63) rows -> row .
    ]               reduce using rule 63 (rows -> row .)
    ;               reduce using rule 63 (rows -> row .)


state 69

    (64) row -> elements .
    (65) elements -> elements . , expr
    ]               reduce using rule 64 (row -> elements .)
    ;               reduce using rule 64 (row -> elements .)
    ,               shift and go to state 98


state 70

    (66) elements -> expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ,               reduce using rule 66 (elements -> expr .)
    ]               reduce using rule 66 (elements -> expr .)
    ;               reduce using rule 66 (elements -> expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 71

    (27) compound_block -> { statements } .
    ;               reduce using rule 27 (compound_block -> { statements } .)
    {               reduce using rule 27 (compound_block -> { statements } .)
    FOR             reduce using rule 27 (compound_block -> { statements } .)
    WHILE           reduce using rule 27 (compound_block -> { statements } .)
    IF              reduce using rule 27 (compound_block -> { statements } .)
    PRINT           reduce using rule 27 (compound_block -> { statements } .)
    RETURN          reduce using rule 27 (compound_block -> { statements } .)
    CONTINUE        reduce using rule 27 (compound_block -> { statements } .)
    BREAK           reduce using rule 27 (compound_block -> { statements } .)
    NEGATE          reduce using rule 27 (compound_block -> { statements } .)
    MINUS           reduce using rule 27 (compound_block -> { statements } .)
    ID              reduce using rule 27 (compound_block -> { statements } .)
    STRING          reduce using rule 27 (compound_block -> { statements } .)
    SCINOTATION     reduce using rule 27 (compound_block -> { statements } .)
    FLOATNUM        reduce using rule 27 (compound_block -> { statements } .)
    INTNUM          reduce using rule 27 (compound_block -> { statements } .)
    (               reduce using rule 27 (compound_block -> { statements } .)
    ZEROS           reduce using rule 27 (compound_block -> { statements } .)
    EYE             reduce using rule 27 (compound_block -> { statements } .)
    ONES            reduce using rule 27 (compound_block -> { statements } .)
    [               reduce using rule 27 (compound_block -> { statements } .)
    $end            reduce using rule 27 (compound_block -> { statements } .)
    }               reduce using rule 27 (compound_block -> { statements } .)
    ELSE            reduce using rule 27 (compound_block -> { statements } .)


state 72

    (23) compound_stmt -> FOR ID = . range_expr statement
    (67) range_expr -> . expr : expr
    (68) range_expr -> . expr : expr : expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    range_expr                     shift and go to state 99
    expr                           shift and go to state 100
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 73

    (46) index -> ID [ idx_list . ]
    (59) idx_list -> idx_list . , INTNUM
    ]               shift and go to state 101
    ,               shift and go to state 102


state 74

    (60) idx_list -> INTNUM .
    ]               reduce using rule 60 (idx_list -> INTNUM .)
    ,               reduce using rule 60 (idx_list -> INTNUM .)
    )               reduce using rule 60 (idx_list -> INTNUM .)


state 75

    (24) compound_stmt -> WHILE ( condition . ) statement
    )               shift and go to state 103


state 76

    (28) condition -> expr . GE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LE expr
    (31) condition -> expr . LT expr
    (32) condition -> expr . NE expr
    (33) condition -> expr . EQ expr
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    GE              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    LT              shift and go to state 107
    NE              shift and go to state 108
    EQ              shift and go to state 109
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 77

    (51) factor -> ( expr ) .
    '               reduce using rule 51 (factor -> ( expr ) .)
    DOTDIV          reduce using rule 51 (factor -> ( expr ) .)
    DOTMUL          reduce using rule 51 (factor -> ( expr ) .)
    DIVIDE          reduce using rule 51 (factor -> ( expr ) .)
    TIMES           reduce using rule 51 (factor -> ( expr ) .)
    DOTSUB          reduce using rule 51 (factor -> ( expr ) .)
    DOTADD          reduce using rule 51 (factor -> ( expr ) .)
    MINUS           reduce using rule 51 (factor -> ( expr ) .)
    PLUS            reduce using rule 51 (factor -> ( expr ) .)
    ;               reduce using rule 51 (factor -> ( expr ) .)
    )               reduce using rule 51 (factor -> ( expr ) .)
    ,               reduce using rule 51 (factor -> ( expr ) .)
    ]               reduce using rule 51 (factor -> ( expr ) .)
    GE              reduce using rule 51 (factor -> ( expr ) .)
    GT              reduce using rule 51 (factor -> ( expr ) .)
    LE              reduce using rule 51 (factor -> ( expr ) .)
    LT              reduce using rule 51 (factor -> ( expr ) .)
    NE              reduce using rule 51 (factor -> ( expr ) .)
    EQ              reduce using rule 51 (factor -> ( expr ) .)
    :               reduce using rule 51 (factor -> ( expr ) .)
    {               reduce using rule 51 (factor -> ( expr ) .)
    FOR             reduce using rule 51 (factor -> ( expr ) .)
    WHILE           reduce using rule 51 (factor -> ( expr ) .)
    IF              reduce using rule 51 (factor -> ( expr ) .)
    PRINT           reduce using rule 51 (factor -> ( expr ) .)
    RETURN          reduce using rule 51 (factor -> ( expr ) .)
    CONTINUE        reduce using rule 51 (factor -> ( expr ) .)
    BREAK           reduce using rule 51 (factor -> ( expr ) .)
    NEGATE          reduce using rule 51 (factor -> ( expr ) .)
    ID              reduce using rule 51 (factor -> ( expr ) .)
    STRING          reduce using rule 51 (factor -> ( expr ) .)
    SCINOTATION     reduce using rule 51 (factor -> ( expr ) .)
    FLOATNUM        reduce using rule 51 (factor -> ( expr ) .)
    INTNUM          reduce using rule 51 (factor -> ( expr ) .)
    (               reduce using rule 51 (factor -> ( expr ) .)
    ZEROS           reduce using rule 51 (factor -> ( expr ) .)
    EYE             reduce using rule 51 (factor -> ( expr ) .)
    ONES            reduce using rule 51 (factor -> ( expr ) .)
    [               reduce using rule 51 (factor -> ( expr ) .)


state 78

    (25) compound_stmt -> IF ( condition . ) statement ELSE statement
    (26) compound_stmt -> IF ( condition . ) statement
    )               shift and go to state 110


state 79

    (22) print_list -> expr , . print_list
    (21) print_list -> . expr
    (22) print_list -> . expr , print_list
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 46
    print_list                     shift and go to state 111
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 80

    (35) expr -> expr DOTSUB term .
    (42) term -> term . DOTDIV factor
    (43) term -> term . DOTMUL factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . TIMES factor
    DOTSUB          reduce using rule 35 (expr -> expr DOTSUB term .)
    DOTADD          reduce using rule 35 (expr -> expr DOTSUB term .)
    MINUS           reduce using rule 35 (expr -> expr DOTSUB term .)
    PLUS            reduce using rule 35 (expr -> expr DOTSUB term .)
    ;               reduce using rule 35 (expr -> expr DOTSUB term .)
    )               reduce using rule 35 (expr -> expr DOTSUB term .)
    ,               reduce using rule 35 (expr -> expr DOTSUB term .)
    ]               reduce using rule 35 (expr -> expr DOTSUB term .)
    GE              reduce using rule 35 (expr -> expr DOTSUB term .)
    GT              reduce using rule 35 (expr -> expr DOTSUB term .)
    LE              reduce using rule 35 (expr -> expr DOTSUB term .)
    LT              reduce using rule 35 (expr -> expr DOTSUB term .)
    NE              reduce using rule 35 (expr -> expr DOTSUB term .)
    EQ              reduce using rule 35 (expr -> expr DOTSUB term .)
    :               reduce using rule 35 (expr -> expr DOTSUB term .)
    {               reduce using rule 35 (expr -> expr DOTSUB term .)
    FOR             reduce using rule 35 (expr -> expr DOTSUB term .)
    WHILE           reduce using rule 35 (expr -> expr DOTSUB term .)
    IF              reduce using rule 35 (expr -> expr DOTSUB term .)
    PRINT           reduce using rule 35 (expr -> expr DOTSUB term .)
    RETURN          reduce using rule 35 (expr -> expr DOTSUB term .)
    CONTINUE        reduce using rule 35 (expr -> expr DOTSUB term .)
    BREAK           reduce using rule 35 (expr -> expr DOTSUB term .)
    NEGATE          reduce using rule 35 (expr -> expr DOTSUB term .)
    ID              reduce using rule 35 (expr -> expr DOTSUB term .)
    STRING          reduce using rule 35 (expr -> expr DOTSUB term .)
    SCINOTATION     reduce using rule 35 (expr -> expr DOTSUB term .)
    FLOATNUM        reduce using rule 35 (expr -> expr DOTSUB term .)
    INTNUM          reduce using rule 35 (expr -> expr DOTSUB term .)
    (               reduce using rule 35 (expr -> expr DOTSUB term .)
    ZEROS           reduce using rule 35 (expr -> expr DOTSUB term .)
    EYE             reduce using rule 35 (expr -> expr DOTSUB term .)
    ONES            reduce using rule 35 (expr -> expr DOTSUB term .)
    [               reduce using rule 35 (expr -> expr DOTSUB term .)
    DOTDIV          shift and go to state 52
    DOTMUL          shift and go to state 53
    DIVIDE          shift and go to state 54
    TIMES           shift and go to state 55


state 81

    (36) expr -> expr DOTADD term .
    (42) term -> term . DOTDIV factor
    (43) term -> term . DOTMUL factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . TIMES factor
    DOTSUB          reduce using rule 36 (expr -> expr DOTADD term .)
    DOTADD          reduce using rule 36 (expr -> expr DOTADD term .)
    MINUS           reduce using rule 36 (expr -> expr DOTADD term .)
    PLUS            reduce using rule 36 (expr -> expr DOTADD term .)
    ;               reduce using rule 36 (expr -> expr DOTADD term .)
    )               reduce using rule 36 (expr -> expr DOTADD term .)
    ,               reduce using rule 36 (expr -> expr DOTADD term .)
    ]               reduce using rule 36 (expr -> expr DOTADD term .)
    GE              reduce using rule 36 (expr -> expr DOTADD term .)
    GT              reduce using rule 36 (expr -> expr DOTADD term .)
    LE              reduce using rule 36 (expr -> expr DOTADD term .)
    LT              reduce using rule 36 (expr -> expr DOTADD term .)
    NE              reduce using rule 36 (expr -> expr DOTADD term .)
    EQ              reduce using rule 36 (expr -> expr DOTADD term .)
    :               reduce using rule 36 (expr -> expr DOTADD term .)
    {               reduce using rule 36 (expr -> expr DOTADD term .)
    FOR             reduce using rule 36 (expr -> expr DOTADD term .)
    WHILE           reduce using rule 36 (expr -> expr DOTADD term .)
    IF              reduce using rule 36 (expr -> expr DOTADD term .)
    PRINT           reduce using rule 36 (expr -> expr DOTADD term .)
    RETURN          reduce using rule 36 (expr -> expr DOTADD term .)
    CONTINUE        reduce using rule 36 (expr -> expr DOTADD term .)
    BREAK           reduce using rule 36 (expr -> expr DOTADD term .)
    NEGATE          reduce using rule 36 (expr -> expr DOTADD term .)
    ID              reduce using rule 36 (expr -> expr DOTADD term .)
    STRING          reduce using rule 36 (expr -> expr DOTADD term .)
    SCINOTATION     reduce using rule 36 (expr -> expr DOTADD term .)
    FLOATNUM        reduce using rule 36 (expr -> expr DOTADD term .)
    INTNUM          reduce using rule 36 (expr -> expr DOTADD term .)
    (               reduce using rule 36 (expr -> expr DOTADD term .)
    ZEROS           reduce using rule 36 (expr -> expr DOTADD term .)
    EYE             reduce using rule 36 (expr -> expr DOTADD term .)
    ONES            reduce using rule 36 (expr -> expr DOTADD term .)
    [               reduce using rule 36 (expr -> expr DOTADD term .)
    DOTDIV          shift and go to state 52
    DOTMUL          shift and go to state 53
    DIVIDE          shift and go to state 54
    TIMES           shift and go to state 55


state 82

    (37) expr -> expr MINUS term .
    (42) term -> term . DOTDIV factor
    (43) term -> term . DOTMUL factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . TIMES factor
    DOTSUB          reduce using rule 37 (expr -> expr MINUS term .)
    DOTADD          reduce using rule 37 (expr -> expr MINUS term .)
    MINUS           reduce using rule 37 (expr -> expr MINUS term .)
    PLUS            reduce using rule 37 (expr -> expr MINUS term .)
    ;               reduce using rule 37 (expr -> expr MINUS term .)
    )               reduce using rule 37 (expr -> expr MINUS term .)
    ,               reduce using rule 37 (expr -> expr MINUS term .)
    ]               reduce using rule 37 (expr -> expr MINUS term .)
    GE              reduce using rule 37 (expr -> expr MINUS term .)
    GT              reduce using rule 37 (expr -> expr MINUS term .)
    LE              reduce using rule 37 (expr -> expr MINUS term .)
    LT              reduce using rule 37 (expr -> expr MINUS term .)
    NE              reduce using rule 37 (expr -> expr MINUS term .)
    EQ              reduce using rule 37 (expr -> expr MINUS term .)
    :               reduce using rule 37 (expr -> expr MINUS term .)
    {               reduce using rule 37 (expr -> expr MINUS term .)
    FOR             reduce using rule 37 (expr -> expr MINUS term .)
    WHILE           reduce using rule 37 (expr -> expr MINUS term .)
    IF              reduce using rule 37 (expr -> expr MINUS term .)
    PRINT           reduce using rule 37 (expr -> expr MINUS term .)
    RETURN          reduce using rule 37 (expr -> expr MINUS term .)
    CONTINUE        reduce using rule 37 (expr -> expr MINUS term .)
    BREAK           reduce using rule 37 (expr -> expr MINUS term .)
    NEGATE          reduce using rule 37 (expr -> expr MINUS term .)
    ID              reduce using rule 37 (expr -> expr MINUS term .)
    STRING          reduce using rule 37 (expr -> expr MINUS term .)
    SCINOTATION     reduce using rule 37 (expr -> expr MINUS term .)
    FLOATNUM        reduce using rule 37 (expr -> expr MINUS term .)
    INTNUM          reduce using rule 37 (expr -> expr MINUS term .)
    (               reduce using rule 37 (expr -> expr MINUS term .)
    ZEROS           reduce using rule 37 (expr -> expr MINUS term .)
    EYE             reduce using rule 37 (expr -> expr MINUS term .)
    ONES            reduce using rule 37 (expr -> expr MINUS term .)
    [               reduce using rule 37 (expr -> expr MINUS term .)
    DOTDIV          shift and go to state 52
    DOTMUL          shift and go to state 53
    DIVIDE          shift and go to state 54
    TIMES           shift and go to state 55


state 83

    (38) expr -> expr PLUS term .
    (42) term -> term . DOTDIV factor
    (43) term -> term . DOTMUL factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . TIMES factor
    DOTSUB          reduce using rule 38 (expr -> expr PLUS term .)
    DOTADD          reduce using rule 38 (expr -> expr PLUS term .)
    MINUS           reduce using rule 38 (expr -> expr PLUS term .)
    PLUS            reduce using rule 38 (expr -> expr PLUS term .)
    ;               reduce using rule 38 (expr -> expr PLUS term .)
    )               reduce using rule 38 (expr -> expr PLUS term .)
    ,               reduce using rule 38 (expr -> expr PLUS term .)
    ]               reduce using rule 38 (expr -> expr PLUS term .)
    GE              reduce using rule 38 (expr -> expr PLUS term .)
    GT              reduce using rule 38 (expr -> expr PLUS term .)
    LE              reduce using rule 38 (expr -> expr PLUS term .)
    LT              reduce using rule 38 (expr -> expr PLUS term .)
    NE              reduce using rule 38 (expr -> expr PLUS term .)
    EQ              reduce using rule 38 (expr -> expr PLUS term .)
    :               reduce using rule 38 (expr -> expr PLUS term .)
    {               reduce using rule 38 (expr -> expr PLUS term .)
    FOR             reduce using rule 38 (expr -> expr PLUS term .)
    WHILE           reduce using rule 38 (expr -> expr PLUS term .)
    IF              reduce using rule 38 (expr -> expr PLUS term .)
    PRINT           reduce using rule 38 (expr -> expr PLUS term .)
    RETURN          reduce using rule 38 (expr -> expr PLUS term .)
    CONTINUE        reduce using rule 38 (expr -> expr PLUS term .)
    BREAK           reduce using rule 38 (expr -> expr PLUS term .)
    NEGATE          reduce using rule 38 (expr -> expr PLUS term .)
    ID              reduce using rule 38 (expr -> expr PLUS term .)
    STRING          reduce using rule 38 (expr -> expr PLUS term .)
    SCINOTATION     reduce using rule 38 (expr -> expr PLUS term .)
    FLOATNUM        reduce using rule 38 (expr -> expr PLUS term .)
    INTNUM          reduce using rule 38 (expr -> expr PLUS term .)
    (               reduce using rule 38 (expr -> expr PLUS term .)
    ZEROS           reduce using rule 38 (expr -> expr PLUS term .)
    EYE             reduce using rule 38 (expr -> expr PLUS term .)
    ONES            reduce using rule 38 (expr -> expr PLUS term .)
    [               reduce using rule 38 (expr -> expr PLUS term .)
    DOTDIV          shift and go to state 52
    DOTMUL          shift and go to state 53
    DIVIDE          shift and go to state 54
    TIMES           shift and go to state 55


state 84

    (42) term -> term DOTDIV factor .
    (56) factor -> factor . '
    DOTDIV          reduce using rule 42 (term -> term DOTDIV factor .)
    DOTMUL          reduce using rule 42 (term -> term DOTDIV factor .)
    DIVIDE          reduce using rule 42 (term -> term DOTDIV factor .)
    TIMES           reduce using rule 42 (term -> term DOTDIV factor .)
    DOTSUB          reduce using rule 42 (term -> term DOTDIV factor .)
    DOTADD          reduce using rule 42 (term -> term DOTDIV factor .)
    MINUS           reduce using rule 42 (term -> term DOTDIV factor .)
    PLUS            reduce using rule 42 (term -> term DOTDIV factor .)
    ;               reduce using rule 42 (term -> term DOTDIV factor .)
    )               reduce using rule 42 (term -> term DOTDIV factor .)
    ,               reduce using rule 42 (term -> term DOTDIV factor .)
    ]               reduce using rule 42 (term -> term DOTDIV factor .)
    GE              reduce using rule 42 (term -> term DOTDIV factor .)
    GT              reduce using rule 42 (term -> term DOTDIV factor .)
    LE              reduce using rule 42 (term -> term DOTDIV factor .)
    LT              reduce using rule 42 (term -> term DOTDIV factor .)
    NE              reduce using rule 42 (term -> term DOTDIV factor .)
    EQ              reduce using rule 42 (term -> term DOTDIV factor .)
    :               reduce using rule 42 (term -> term DOTDIV factor .)
    {               reduce using rule 42 (term -> term DOTDIV factor .)
    FOR             reduce using rule 42 (term -> term DOTDIV factor .)
    WHILE           reduce using rule 42 (term -> term DOTDIV factor .)
    IF              reduce using rule 42 (term -> term DOTDIV factor .)
    PRINT           reduce using rule 42 (term -> term DOTDIV factor .)
    RETURN          reduce using rule 42 (term -> term DOTDIV factor .)
    CONTINUE        reduce using rule 42 (term -> term DOTDIV factor .)
    BREAK           reduce using rule 42 (term -> term DOTDIV factor .)
    NEGATE          reduce using rule 42 (term -> term DOTDIV factor .)
    ID              reduce using rule 42 (term -> term DOTDIV factor .)
    STRING          reduce using rule 42 (term -> term DOTDIV factor .)
    SCINOTATION     reduce using rule 42 (term -> term DOTDIV factor .)
    FLOATNUM        reduce using rule 42 (term -> term DOTDIV factor .)
    INTNUM          reduce using rule 42 (term -> term DOTDIV factor .)
    (               reduce using rule 42 (term -> term DOTDIV factor .)
    ZEROS           reduce using rule 42 (term -> term DOTDIV factor .)
    EYE             reduce using rule 42 (term -> term DOTDIV factor .)
    ONES            reduce using rule 42 (term -> term DOTDIV factor .)
    [               reduce using rule 42 (term -> term DOTDIV factor .)
    '               shift and go to state 63


state 85

    (43) term -> term DOTMUL factor .
    (56) factor -> factor . '
    DOTDIV          reduce using rule 43 (term -> term DOTMUL factor .)
    DOTMUL          reduce using rule 43 (term -> term DOTMUL factor .)
    DIVIDE          reduce using rule 43 (term -> term DOTMUL factor .)
    TIMES           reduce using rule 43 (term -> term DOTMUL factor .)
    DOTSUB          reduce using rule 43 (term -> term DOTMUL factor .)
    DOTADD          reduce using rule 43 (term -> term DOTMUL factor .)
    MINUS           reduce using rule 43 (term -> term DOTMUL factor .)
    PLUS            reduce using rule 43 (term -> term DOTMUL factor .)
    ;               reduce using rule 43 (term -> term DOTMUL factor .)
    )               reduce using rule 43 (term -> term DOTMUL factor .)
    ,               reduce using rule 43 (term -> term DOTMUL factor .)
    ]               reduce using rule 43 (term -> term DOTMUL factor .)
    GE              reduce using rule 43 (term -> term DOTMUL factor .)
    GT              reduce using rule 43 (term -> term DOTMUL factor .)
    LE              reduce using rule 43 (term -> term DOTMUL factor .)
    LT              reduce using rule 43 (term -> term DOTMUL factor .)
    NE              reduce using rule 43 (term -> term DOTMUL factor .)
    EQ              reduce using rule 43 (term -> term DOTMUL factor .)
    :               reduce using rule 43 (term -> term DOTMUL factor .)
    {               reduce using rule 43 (term -> term DOTMUL factor .)
    FOR             reduce using rule 43 (term -> term DOTMUL factor .)
    WHILE           reduce using rule 43 (term -> term DOTMUL factor .)
    IF              reduce using rule 43 (term -> term DOTMUL factor .)
    PRINT           reduce using rule 43 (term -> term DOTMUL factor .)
    RETURN          reduce using rule 43 (term -> term DOTMUL factor .)
    CONTINUE        reduce using rule 43 (term -> term DOTMUL factor .)
    BREAK           reduce using rule 43 (term -> term DOTMUL factor .)
    NEGATE          reduce using rule 43 (term -> term DOTMUL factor .)
    ID              reduce using rule 43 (term -> term DOTMUL factor .)
    STRING          reduce using rule 43 (term -> term DOTMUL factor .)
    SCINOTATION     reduce using rule 43 (term -> term DOTMUL factor .)
    FLOATNUM        reduce using rule 43 (term -> term DOTMUL factor .)
    INTNUM          reduce using rule 43 (term -> term DOTMUL factor .)
    (               reduce using rule 43 (term -> term DOTMUL factor .)
    ZEROS           reduce using rule 43 (term -> term DOTMUL factor .)
    EYE             reduce using rule 43 (term -> term DOTMUL factor .)
    ONES            reduce using rule 43 (term -> term DOTMUL factor .)
    [               reduce using rule 43 (term -> term DOTMUL factor .)
    '               shift and go to state 63


state 86

    (44) term -> term DIVIDE factor .
    (56) factor -> factor . '
    DOTDIV          reduce using rule 44 (term -> term DIVIDE factor .)
    DOTMUL          reduce using rule 44 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 44 (term -> term DIVIDE factor .)
    TIMES           reduce using rule 44 (term -> term DIVIDE factor .)
    DOTSUB          reduce using rule 44 (term -> term DIVIDE factor .)
    DOTADD          reduce using rule 44 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 44 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 44 (term -> term DIVIDE factor .)
    ;               reduce using rule 44 (term -> term DIVIDE factor .)
    )               reduce using rule 44 (term -> term DIVIDE factor .)
    ,               reduce using rule 44 (term -> term DIVIDE factor .)
    ]               reduce using rule 44 (term -> term DIVIDE factor .)
    GE              reduce using rule 44 (term -> term DIVIDE factor .)
    GT              reduce using rule 44 (term -> term DIVIDE factor .)
    LE              reduce using rule 44 (term -> term DIVIDE factor .)
    LT              reduce using rule 44 (term -> term DIVIDE factor .)
    NE              reduce using rule 44 (term -> term DIVIDE factor .)
    EQ              reduce using rule 44 (term -> term DIVIDE factor .)
    :               reduce using rule 44 (term -> term DIVIDE factor .)
    {               reduce using rule 44 (term -> term DIVIDE factor .)
    FOR             reduce using rule 44 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 44 (term -> term DIVIDE factor .)
    IF              reduce using rule 44 (term -> term DIVIDE factor .)
    PRINT           reduce using rule 44 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 44 (term -> term DIVIDE factor .)
    CONTINUE        reduce using rule 44 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 44 (term -> term DIVIDE factor .)
    NEGATE          reduce using rule 44 (term -> term DIVIDE factor .)
    ID              reduce using rule 44 (term -> term DIVIDE factor .)
    STRING          reduce using rule 44 (term -> term DIVIDE factor .)
    SCINOTATION     reduce using rule 44 (term -> term DIVIDE factor .)
    FLOATNUM        reduce using rule 44 (term -> term DIVIDE factor .)
    INTNUM          reduce using rule 44 (term -> term DIVIDE factor .)
    (               reduce using rule 44 (term -> term DIVIDE factor .)
    ZEROS           reduce using rule 44 (term -> term DIVIDE factor .)
    EYE             reduce using rule 44 (term -> term DIVIDE factor .)
    ONES            reduce using rule 44 (term -> term DIVIDE factor .)
    [               reduce using rule 44 (term -> term DIVIDE factor .)
    '               shift and go to state 63


state 87

    (45) term -> term TIMES factor .
    (56) factor -> factor . '
    DOTDIV          reduce using rule 45 (term -> term TIMES factor .)
    DOTMUL          reduce using rule 45 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 45 (term -> term TIMES factor .)
    TIMES           reduce using rule 45 (term -> term TIMES factor .)
    DOTSUB          reduce using rule 45 (term -> term TIMES factor .)
    DOTADD          reduce using rule 45 (term -> term TIMES factor .)
    MINUS           reduce using rule 45 (term -> term TIMES factor .)
    PLUS            reduce using rule 45 (term -> term TIMES factor .)
    ;               reduce using rule 45 (term -> term TIMES factor .)
    )               reduce using rule 45 (term -> term TIMES factor .)
    ,               reduce using rule 45 (term -> term TIMES factor .)
    ]               reduce using rule 45 (term -> term TIMES factor .)
    GE              reduce using rule 45 (term -> term TIMES factor .)
    GT              reduce using rule 45 (term -> term TIMES factor .)
    LE              reduce using rule 45 (term -> term TIMES factor .)
    LT              reduce using rule 45 (term -> term TIMES factor .)
    NE              reduce using rule 45 (term -> term TIMES factor .)
    EQ              reduce using rule 45 (term -> term TIMES factor .)
    :               reduce using rule 45 (term -> term TIMES factor .)
    {               reduce using rule 45 (term -> term TIMES factor .)
    FOR             reduce using rule 45 (term -> term TIMES factor .)
    WHILE           reduce using rule 45 (term -> term TIMES factor .)
    IF              reduce using rule 45 (term -> term TIMES factor .)
    PRINT           reduce using rule 45 (term -> term TIMES factor .)
    RETURN          reduce using rule 45 (term -> term TIMES factor .)
    CONTINUE        reduce using rule 45 (term -> term TIMES factor .)
    BREAK           reduce using rule 45 (term -> term TIMES factor .)
    NEGATE          reduce using rule 45 (term -> term TIMES factor .)
    ID              reduce using rule 45 (term -> term TIMES factor .)
    STRING          reduce using rule 45 (term -> term TIMES factor .)
    SCINOTATION     reduce using rule 45 (term -> term TIMES factor .)
    FLOATNUM        reduce using rule 45 (term -> term TIMES factor .)
    INTNUM          reduce using rule 45 (term -> term TIMES factor .)
    (               reduce using rule 45 (term -> term TIMES factor .)
    ZEROS           reduce using rule 45 (term -> term TIMES factor .)
    EYE             reduce using rule 45 (term -> term TIMES factor .)
    ONES            reduce using rule 45 (term -> term TIMES factor .)
    [               reduce using rule 45 (term -> term TIMES factor .)
    '               shift and go to state 63


state 88

    (16) assignment -> lvalue DIVASSIGN expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 16 (assignment -> lvalue DIVASSIGN expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 89

    (17) assignment -> lvalue MULASSIGN expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 17 (assignment -> lvalue MULASSIGN expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 90

    (18) assignment -> lvalue SUBASSIGN expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 18 (assignment -> lvalue SUBASSIGN expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 91

    (19) assignment -> lvalue ADDASSIGN expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 19 (assignment -> lvalue ADDASSIGN expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 92

    (20) assignment -> lvalue = expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 20 (assignment -> lvalue = expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 93

    (53) factor -> ZEROS ( idx_list . )
    (59) idx_list -> idx_list . , INTNUM
    )               shift and go to state 112
    ,               shift and go to state 102


state 94

    (54) factor -> EYE ( idx_list . )
    (59) idx_list -> idx_list . , INTNUM
    )               shift and go to state 113
    ,               shift and go to state 102


state 95

    (55) factor -> ONES ( idx_list . )
    (59) idx_list -> idx_list . , INTNUM
    )               shift and go to state 114
    ,               shift and go to state 102


state 96

    (61) matrix_literal -> [ rows ] .
    '               reduce using rule 61 (matrix_literal -> [ rows ] .)
    DOTDIV          reduce using rule 61 (matrix_literal -> [ rows ] .)
    DOTMUL          reduce using rule 61 (matrix_literal -> [ rows ] .)
    DIVIDE          reduce using rule 61 (matrix_literal -> [ rows ] .)
    TIMES           reduce using rule 61 (matrix_literal -> [ rows ] .)
    DOTSUB          reduce using rule 61 (matrix_literal -> [ rows ] .)
    DOTADD          reduce using rule 61 (matrix_literal -> [ rows ] .)
    MINUS           reduce using rule 61 (matrix_literal -> [ rows ] .)
    PLUS            reduce using rule 61 (matrix_literal -> [ rows ] .)
    ;               reduce using rule 61 (matrix_literal -> [ rows ] .)
    )               reduce using rule 61 (matrix_literal -> [ rows ] .)
    ,               reduce using rule 61 (matrix_literal -> [ rows ] .)
    ]               reduce using rule 61 (matrix_literal -> [ rows ] .)
    GE              reduce using rule 61 (matrix_literal -> [ rows ] .)
    GT              reduce using rule 61 (matrix_literal -> [ rows ] .)
    LE              reduce using rule 61 (matrix_literal -> [ rows ] .)
    LT              reduce using rule 61 (matrix_literal -> [ rows ] .)
    NE              reduce using rule 61 (matrix_literal -> [ rows ] .)
    EQ              reduce using rule 61 (matrix_literal -> [ rows ] .)
    :               reduce using rule 61 (matrix_literal -> [ rows ] .)
    {               reduce using rule 61 (matrix_literal -> [ rows ] .)
    FOR             reduce using rule 61 (matrix_literal -> [ rows ] .)
    WHILE           reduce using rule 61 (matrix_literal -> [ rows ] .)
    IF              reduce using rule 61 (matrix_literal -> [ rows ] .)
    PRINT           reduce using rule 61 (matrix_literal -> [ rows ] .)
    RETURN          reduce using rule 61 (matrix_literal -> [ rows ] .)
    CONTINUE        reduce using rule 61 (matrix_literal -> [ rows ] .)
    BREAK           reduce using rule 61 (matrix_literal -> [ rows ] .)
    NEGATE          reduce using rule 61 (matrix_literal -> [ rows ] .)
    ID              reduce using rule 61 (matrix_literal -> [ rows ] .)
    STRING          reduce using rule 61 (matrix_literal -> [ rows ] .)
    SCINOTATION     reduce using rule 61 (matrix_literal -> [ rows ] .)
    FLOATNUM        reduce using rule 61 (matrix_literal -> [ rows ] .)
    INTNUM          reduce using rule 61 (matrix_literal -> [ rows ] .)
    (               reduce using rule 61 (matrix_literal -> [ rows ] .)
    ZEROS           reduce using rule 61 (matrix_literal -> [ rows ] .)
    EYE             reduce using rule 61 (matrix_literal -> [ rows ] .)
    ONES            reduce using rule 61 (matrix_literal -> [ rows ] .)
    [               reduce using rule 61 (matrix_literal -> [ rows ] .)


state 97

    (62) rows -> rows ; . row
    (64) row -> . elements
    (65) elements -> . elements , expr
    (66) elements -> . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    row                            shift and go to state 115
    elements                       shift and go to state 69
    expr                           shift and go to state 70
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 98

    (65) elements -> elements , . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 116
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 99

    (23) compound_stmt -> FOR ID = range_expr . statement
    (4) statement -> . ;
    (5) statement -> . compound_block
    (6) statement -> . compound_stmt
    (7) statement -> . simple_stmt ;
    (27) compound_block -> . { statements }
    (23) compound_stmt -> . FOR ID = range_expr statement
    (24) compound_stmt -> . WHILE ( condition ) statement
    (25) compound_stmt -> . IF ( condition ) statement ELSE statement
    (26) compound_stmt -> . IF ( condition ) statement
    (8) simple_stmt -> . PRINT print_list
    (9) simple_stmt -> . RETURN expr
    (10) simple_stmt -> . CONTINUE
    (11) simple_stmt -> . BREAK
    (12) simple_stmt -> . expr
    (13) simple_stmt -> . assignment
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (16) assignment -> . lvalue DIVASSIGN expr
    (17) assignment -> . lvalue MULASSIGN expr
    (18) assignment -> . lvalue SUBASSIGN expr
    (19) assignment -> . lvalue ADDASSIGN expr
    (20) assignment -> . lvalue = expr
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (14) lvalue -> . index
    (15) lvalue -> . ID
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (46) index -> . ID [ idx_list ]
    (61) matrix_literal -> . [ rows ]
    ;               shift and go to state 4
    {               shift and go to state 8
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 13
    PRINT           shift and go to state 14
    RETURN          shift and go to state 15
    CONTINUE        shift and go to state 17
    BREAK           shift and go to state 18
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    ID              shift and go to state 10
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    [               shift and go to state 34

    statement                      shift and go to state 117
    compound_block                 shift and go to state 5
    compound_stmt                  shift and go to state 6
    simple_stmt                    shift and go to state 7
    expr                           shift and go to state 16
    assignment                     shift and go to state 19
    term                           shift and go to state 20
    lvalue                         shift and go to state 22
    factor                         shift and go to state 24
    index                          shift and go to state 25
    matrix_literal                 shift and go to state 30

state 100

    (67) range_expr -> expr . : expr
    (68) range_expr -> expr . : expr : expr
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    :               shift and go to state 118
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 101

    (46) index -> ID [ idx_list ] .
    DIVASSIGN       reduce using rule 46 (index -> ID [ idx_list ] .)
    MULASSIGN       reduce using rule 46 (index -> ID [ idx_list ] .)
    SUBASSIGN       reduce using rule 46 (index -> ID [ idx_list ] .)
    ADDASSIGN       reduce using rule 46 (index -> ID [ idx_list ] .)
    =               reduce using rule 46 (index -> ID [ idx_list ] .)
    '               reduce using rule 46 (index -> ID [ idx_list ] .)
    DOTDIV          reduce using rule 46 (index -> ID [ idx_list ] .)
    DOTMUL          reduce using rule 46 (index -> ID [ idx_list ] .)
    DIVIDE          reduce using rule 46 (index -> ID [ idx_list ] .)
    TIMES           reduce using rule 46 (index -> ID [ idx_list ] .)
    DOTSUB          reduce using rule 46 (index -> ID [ idx_list ] .)
    DOTADD          reduce using rule 46 (index -> ID [ idx_list ] .)
    MINUS           reduce using rule 46 (index -> ID [ idx_list ] .)
    PLUS            reduce using rule 46 (index -> ID [ idx_list ] .)
    ;               reduce using rule 46 (index -> ID [ idx_list ] .)
    )               reduce using rule 46 (index -> ID [ idx_list ] .)
    ,               reduce using rule 46 (index -> ID [ idx_list ] .)
    ]               reduce using rule 46 (index -> ID [ idx_list ] .)
    GE              reduce using rule 46 (index -> ID [ idx_list ] .)
    GT              reduce using rule 46 (index -> ID [ idx_list ] .)
    LE              reduce using rule 46 (index -> ID [ idx_list ] .)
    LT              reduce using rule 46 (index -> ID [ idx_list ] .)
    NE              reduce using rule 46 (index -> ID [ idx_list ] .)
    EQ              reduce using rule 46 (index -> ID [ idx_list ] .)
    :               reduce using rule 46 (index -> ID [ idx_list ] .)
    {               reduce using rule 46 (index -> ID [ idx_list ] .)
    FOR             reduce using rule 46 (index -> ID [ idx_list ] .)
    WHILE           reduce using rule 46 (index -> ID [ idx_list ] .)
    IF              reduce using rule 46 (index -> ID [ idx_list ] .)
    PRINT           reduce using rule 46 (index -> ID [ idx_list ] .)
    RETURN          reduce using rule 46 (index -> ID [ idx_list ] .)
    CONTINUE        reduce using rule 46 (index -> ID [ idx_list ] .)
    BREAK           reduce using rule 46 (index -> ID [ idx_list ] .)
    NEGATE          reduce using rule 46 (index -> ID [ idx_list ] .)
    ID              reduce using rule 46 (index -> ID [ idx_list ] .)
    STRING          reduce using rule 46 (index -> ID [ idx_list ] .)
    SCINOTATION     reduce using rule 46 (index -> ID [ idx_list ] .)
    FLOATNUM        reduce using rule 46 (index -> ID [ idx_list ] .)
    INTNUM          reduce using rule 46 (index -> ID [ idx_list ] .)
    (               reduce using rule 46 (index -> ID [ idx_list ] .)
    ZEROS           reduce using rule 46 (index -> ID [ idx_list ] .)
    EYE             reduce using rule 46 (index -> ID [ idx_list ] .)
    ONES            reduce using rule 46 (index -> ID [ idx_list ] .)
    [               reduce using rule 46 (index -> ID [ idx_list ] .)


state 102

    (59) idx_list -> idx_list , . INTNUM
    INTNUM          shift and go to state 119


state 103

    (24) compound_stmt -> WHILE ( condition ) . statement
    (4) statement -> . ;
    (5) statement -> . compound_block
    (6) statement -> . compound_stmt
    (7) statement -> . simple_stmt ;
    (27) compound_block -> . { statements }
    (23) compound_stmt -> . FOR ID = range_expr statement
    (24) compound_stmt -> . WHILE ( condition ) statement
    (25) compound_stmt -> . IF ( condition ) statement ELSE statement
    (26) compound_stmt -> . IF ( condition ) statement
    (8) simple_stmt -> . PRINT print_list
    (9) simple_stmt -> . RETURN expr
    (10) simple_stmt -> . CONTINUE
    (11) simple_stmt -> . BREAK
    (12) simple_stmt -> . expr
    (13) simple_stmt -> . assignment
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (16) assignment -> . lvalue DIVASSIGN expr
    (17) assignment -> . lvalue MULASSIGN expr
    (18) assignment -> . lvalue SUBASSIGN expr
    (19) assignment -> . lvalue ADDASSIGN expr
    (20) assignment -> . lvalue = expr
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (14) lvalue -> . index
    (15) lvalue -> . ID
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (46) index -> . ID [ idx_list ]
    (61) matrix_literal -> . [ rows ]
    ;               shift and go to state 4
    {               shift and go to state 8
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 13
    PRINT           shift and go to state 14
    RETURN          shift and go to state 15
    CONTINUE        shift and go to state 17
    BREAK           shift and go to state 18
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    ID              shift and go to state 10
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    [               shift and go to state 34

    statement                      shift and go to state 120
    compound_block                 shift and go to state 5
    compound_stmt                  shift and go to state 6
    simple_stmt                    shift and go to state 7
    expr                           shift and go to state 16
    assignment                     shift and go to state 19
    term                           shift and go to state 20
    lvalue                         shift and go to state 22
    factor                         shift and go to state 24
    index                          shift and go to state 25
    matrix_literal                 shift and go to state 30

state 104

    (28) condition -> expr GE . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 121
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 105

    (29) condition -> expr GT . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 122
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 106

    (30) condition -> expr LE . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 123
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 107

    (31) condition -> expr LT . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 124
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 108

    (32) condition -> expr NE . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 125
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 109

    (33) condition -> expr EQ . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 126
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 110

    (25) compound_stmt -> IF ( condition ) . statement ELSE statement
    (26) compound_stmt -> IF ( condition ) . statement
    (4) statement -> . ;
    (5) statement -> . compound_block
    (6) statement -> . compound_stmt
    (7) statement -> . simple_stmt ;
    (27) compound_block -> . { statements }
    (23) compound_stmt -> . FOR ID = range_expr statement
    (24) compound_stmt -> . WHILE ( condition ) statement
    (25) compound_stmt -> . IF ( condition ) statement ELSE statement
    (26) compound_stmt -> . IF ( condition ) statement
    (8) simple_stmt -> . PRINT print_list
    (9) simple_stmt -> . RETURN expr
    (10) simple_stmt -> . CONTINUE
    (11) simple_stmt -> . BREAK
    (12) simple_stmt -> . expr
    (13) simple_stmt -> . assignment
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (16) assignment -> . lvalue DIVASSIGN expr
    (17) assignment -> . lvalue MULASSIGN expr
    (18) assignment -> . lvalue SUBASSIGN expr
    (19) assignment -> . lvalue ADDASSIGN expr
    (20) assignment -> . lvalue = expr
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (14) lvalue -> . index
    (15) lvalue -> . ID
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (46) index -> . ID [ idx_list ]
    (61) matrix_literal -> . [ rows ]
    ;               shift and go to state 4
    {               shift and go to state 8
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 13
    PRINT           shift and go to state 14
    RETURN          shift and go to state 15
    CONTINUE        shift and go to state 17
    BREAK           shift and go to state 18
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    ID              shift and go to state 10
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    [               shift and go to state 34

    statement                      shift and go to state 127
    compound_block                 shift and go to state 5
    compound_stmt                  shift and go to state 6
    simple_stmt                    shift and go to state 7
    expr                           shift and go to state 16
    assignment                     shift and go to state 19
    term                           shift and go to state 20
    lvalue                         shift and go to state 22
    factor                         shift and go to state 24
    index                          shift and go to state 25
    matrix_literal                 shift and go to state 30

state 111

    (22) print_list -> expr , print_list .
    ;               reduce using rule 22 (print_list -> expr , print_list .)


state 112

    (53) factor -> ZEROS ( idx_list ) .
    '               reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    DOTDIV          reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    DOTMUL          reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    DIVIDE          reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    TIMES           reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    DOTSUB          reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    DOTADD          reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    MINUS           reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    PLUS            reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    ;               reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    )               reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    ,               reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    ]               reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    GE              reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    GT              reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    LE              reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    LT              reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    NE              reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    EQ              reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    :               reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    {               reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    FOR             reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    WHILE           reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    IF              reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    PRINT           reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    RETURN          reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    CONTINUE        reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    BREAK           reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    NEGATE          reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    ID              reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    STRING          reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    SCINOTATION     reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    FLOATNUM        reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    INTNUM          reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    (               reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    ZEROS           reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    EYE             reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    ONES            reduce using rule 53 (factor -> ZEROS ( idx_list ) .)
    [               reduce using rule 53 (factor -> ZEROS ( idx_list ) .)


state 113

    (54) factor -> EYE ( idx_list ) .
    '               reduce using rule 54 (factor -> EYE ( idx_list ) .)
    DOTDIV          reduce using rule 54 (factor -> EYE ( idx_list ) .)
    DOTMUL          reduce using rule 54 (factor -> EYE ( idx_list ) .)
    DIVIDE          reduce using rule 54 (factor -> EYE ( idx_list ) .)
    TIMES           reduce using rule 54 (factor -> EYE ( idx_list ) .)
    DOTSUB          reduce using rule 54 (factor -> EYE ( idx_list ) .)
    DOTADD          reduce using rule 54 (factor -> EYE ( idx_list ) .)
    MINUS           reduce using rule 54 (factor -> EYE ( idx_list ) .)
    PLUS            reduce using rule 54 (factor -> EYE ( idx_list ) .)
    ;               reduce using rule 54 (factor -> EYE ( idx_list ) .)
    )               reduce using rule 54 (factor -> EYE ( idx_list ) .)
    ,               reduce using rule 54 (factor -> EYE ( idx_list ) .)
    ]               reduce using rule 54 (factor -> EYE ( idx_list ) .)
    GE              reduce using rule 54 (factor -> EYE ( idx_list ) .)
    GT              reduce using rule 54 (factor -> EYE ( idx_list ) .)
    LE              reduce using rule 54 (factor -> EYE ( idx_list ) .)
    LT              reduce using rule 54 (factor -> EYE ( idx_list ) .)
    NE              reduce using rule 54 (factor -> EYE ( idx_list ) .)
    EQ              reduce using rule 54 (factor -> EYE ( idx_list ) .)
    :               reduce using rule 54 (factor -> EYE ( idx_list ) .)
    {               reduce using rule 54 (factor -> EYE ( idx_list ) .)
    FOR             reduce using rule 54 (factor -> EYE ( idx_list ) .)
    WHILE           reduce using rule 54 (factor -> EYE ( idx_list ) .)
    IF              reduce using rule 54 (factor -> EYE ( idx_list ) .)
    PRINT           reduce using rule 54 (factor -> EYE ( idx_list ) .)
    RETURN          reduce using rule 54 (factor -> EYE ( idx_list ) .)
    CONTINUE        reduce using rule 54 (factor -> EYE ( idx_list ) .)
    BREAK           reduce using rule 54 (factor -> EYE ( idx_list ) .)
    NEGATE          reduce using rule 54 (factor -> EYE ( idx_list ) .)
    ID              reduce using rule 54 (factor -> EYE ( idx_list ) .)
    STRING          reduce using rule 54 (factor -> EYE ( idx_list ) .)
    SCINOTATION     reduce using rule 54 (factor -> EYE ( idx_list ) .)
    FLOATNUM        reduce using rule 54 (factor -> EYE ( idx_list ) .)
    INTNUM          reduce using rule 54 (factor -> EYE ( idx_list ) .)
    (               reduce using rule 54 (factor -> EYE ( idx_list ) .)
    ZEROS           reduce using rule 54 (factor -> EYE ( idx_list ) .)
    EYE             reduce using rule 54 (factor -> EYE ( idx_list ) .)
    ONES            reduce using rule 54 (factor -> EYE ( idx_list ) .)
    [               reduce using rule 54 (factor -> EYE ( idx_list ) .)


state 114

    (55) factor -> ONES ( idx_list ) .
    '               reduce using rule 55 (factor -> ONES ( idx_list ) .)
    DOTDIV          reduce using rule 55 (factor -> ONES ( idx_list ) .)
    DOTMUL          reduce using rule 55 (factor -> ONES ( idx_list ) .)
    DIVIDE          reduce using rule 55 (factor -> ONES ( idx_list ) .)
    TIMES           reduce using rule 55 (factor -> ONES ( idx_list ) .)
    DOTSUB          reduce using rule 55 (factor -> ONES ( idx_list ) .)
    DOTADD          reduce using rule 55 (factor -> ONES ( idx_list ) .)
    MINUS           reduce using rule 55 (factor -> ONES ( idx_list ) .)
    PLUS            reduce using rule 55 (factor -> ONES ( idx_list ) .)
    ;               reduce using rule 55 (factor -> ONES ( idx_list ) .)
    )               reduce using rule 55 (factor -> ONES ( idx_list ) .)
    ,               reduce using rule 55 (factor -> ONES ( idx_list ) .)
    ]               reduce using rule 55 (factor -> ONES ( idx_list ) .)
    GE              reduce using rule 55 (factor -> ONES ( idx_list ) .)
    GT              reduce using rule 55 (factor -> ONES ( idx_list ) .)
    LE              reduce using rule 55 (factor -> ONES ( idx_list ) .)
    LT              reduce using rule 55 (factor -> ONES ( idx_list ) .)
    NE              reduce using rule 55 (factor -> ONES ( idx_list ) .)
    EQ              reduce using rule 55 (factor -> ONES ( idx_list ) .)
    :               reduce using rule 55 (factor -> ONES ( idx_list ) .)
    {               reduce using rule 55 (factor -> ONES ( idx_list ) .)
    FOR             reduce using rule 55 (factor -> ONES ( idx_list ) .)
    WHILE           reduce using rule 55 (factor -> ONES ( idx_list ) .)
    IF              reduce using rule 55 (factor -> ONES ( idx_list ) .)
    PRINT           reduce using rule 55 (factor -> ONES ( idx_list ) .)
    RETURN          reduce using rule 55 (factor -> ONES ( idx_list ) .)
    CONTINUE        reduce using rule 55 (factor -> ONES ( idx_list ) .)
    BREAK           reduce using rule 55 (factor -> ONES ( idx_list ) .)
    NEGATE          reduce using rule 55 (factor -> ONES ( idx_list ) .)
    ID              reduce using rule 55 (factor -> ONES ( idx_list ) .)
    STRING          reduce using rule 55 (factor -> ONES ( idx_list ) .)
    SCINOTATION     reduce using rule 55 (factor -> ONES ( idx_list ) .)
    FLOATNUM        reduce using rule 55 (factor -> ONES ( idx_list ) .)
    INTNUM          reduce using rule 55 (factor -> ONES ( idx_list ) .)
    (               reduce using rule 55 (factor -> ONES ( idx_list ) .)
    ZEROS           reduce using rule 55 (factor -> ONES ( idx_list ) .)
    EYE             reduce using rule 55 (factor -> ONES ( idx_list ) .)
    ONES            reduce using rule 55 (factor -> ONES ( idx_list ) .)
    [               reduce using rule 55 (factor -> ONES ( idx_list ) .)


state 115

    (62) rows -> rows ; row .
    ]               reduce using rule 62 (rows -> rows ; row .)
    ;               reduce using rule 62 (rows -> rows ; row .)


state 116

    (65) elements -> elements , expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ,               reduce using rule 65 (elements -> elements , expr .)
    ]               reduce using rule 65 (elements -> elements , expr .)
    ;               reduce using rule 65 (elements -> elements , expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 117

    (23) compound_stmt -> FOR ID = range_expr statement .
    ;               reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    {               reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    FOR             reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    WHILE           reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    IF              reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    PRINT           reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    RETURN          reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    CONTINUE        reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    BREAK           reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    NEGATE          reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    MINUS           reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    ID              reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    STRING          reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    SCINOTATION     reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    FLOATNUM        reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    INTNUM          reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    (               reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    ZEROS           reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    EYE             reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    ONES            reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    [               reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    $end            reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    }               reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)
    ELSE            reduce using rule 23 (compound_stmt -> FOR ID = range_expr statement .)


state 118

    (67) range_expr -> expr : . expr
    (68) range_expr -> expr : . expr : expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 128
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 119

    (59) idx_list -> idx_list , INTNUM .
    ]               reduce using rule 59 (idx_list -> idx_list , INTNUM .)
    ,               reduce using rule 59 (idx_list -> idx_list , INTNUM .)
    )               reduce using rule 59 (idx_list -> idx_list , INTNUM .)


state 120

    (24) compound_stmt -> WHILE ( condition ) statement .
    ;               reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    {               reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    FOR             reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    WHILE           reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    IF              reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    PRINT           reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    RETURN          reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    CONTINUE        reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    BREAK           reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    NEGATE          reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    MINUS           reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    ID              reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    STRING          reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    SCINOTATION     reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    FLOATNUM        reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    INTNUM          reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    (               reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    ZEROS           reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    EYE             reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    ONES            reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    [               reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    $end            reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    }               reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)
    ELSE            reduce using rule 24 (compound_stmt -> WHILE ( condition ) statement .)


state 121

    (28) condition -> expr GE expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    )               reduce using rule 28 (condition -> expr GE expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 122

    (29) condition -> expr GT expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    )               reduce using rule 29 (condition -> expr GT expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 123

    (30) condition -> expr LE expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    )               reduce using rule 30 (condition -> expr LE expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 124

    (31) condition -> expr LT expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    )               reduce using rule 31 (condition -> expr LT expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 125

    (32) condition -> expr NE expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    )               reduce using rule 32 (condition -> expr NE expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 126

    (33) condition -> expr EQ expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    )               reduce using rule 33 (condition -> expr EQ expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 127

    (25) compound_stmt -> IF ( condition ) statement . ELSE statement
    (26) compound_stmt -> IF ( condition ) statement .
    ELSE            shift and go to state 129
    ;               reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    {               reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    FOR             reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    WHILE           reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    IF              reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    PRINT           reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    RETURN          reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    CONTINUE        reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    BREAK           reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    NEGATE          reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    MINUS           reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    ID              reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    STRING          reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    SCINOTATION     reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    FLOATNUM        reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    INTNUM          reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    (               reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    ZEROS           reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    EYE             reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    ONES            reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    [               reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    $end            reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)
    }               reduce using rule 26 (compound_stmt -> IF ( condition ) statement .)


state 128

    (67) range_expr -> expr : expr .
    (68) range_expr -> expr : expr . : expr
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 67 (range_expr -> expr : expr .)
    {               reduce using rule 67 (range_expr -> expr : expr .)
    FOR             reduce using rule 67 (range_expr -> expr : expr .)
    WHILE           reduce using rule 67 (range_expr -> expr : expr .)
    IF              reduce using rule 67 (range_expr -> expr : expr .)
    PRINT           reduce using rule 67 (range_expr -> expr : expr .)
    RETURN          reduce using rule 67 (range_expr -> expr : expr .)
    CONTINUE        reduce using rule 67 (range_expr -> expr : expr .)
    BREAK           reduce using rule 67 (range_expr -> expr : expr .)
    NEGATE          reduce using rule 67 (range_expr -> expr : expr .)
    ID              reduce using rule 67 (range_expr -> expr : expr .)
    STRING          reduce using rule 67 (range_expr -> expr : expr .)
    SCINOTATION     reduce using rule 67 (range_expr -> expr : expr .)
    FLOATNUM        reduce using rule 67 (range_expr -> expr : expr .)
    INTNUM          reduce using rule 67 (range_expr -> expr : expr .)
    (               reduce using rule 67 (range_expr -> expr : expr .)
    ZEROS           reduce using rule 67 (range_expr -> expr : expr .)
    EYE             reduce using rule 67 (range_expr -> expr : expr .)
    ONES            reduce using rule 67 (range_expr -> expr : expr .)
    [               reduce using rule 67 (range_expr -> expr : expr .)
    :               shift and go to state 130
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


state 129

    (25) compound_stmt -> IF ( condition ) statement ELSE . statement
    (4) statement -> . ;
    (5) statement -> . compound_block
    (6) statement -> . compound_stmt
    (7) statement -> . simple_stmt ;
    (27) compound_block -> . { statements }
    (23) compound_stmt -> . FOR ID = range_expr statement
    (24) compound_stmt -> . WHILE ( condition ) statement
    (25) compound_stmt -> . IF ( condition ) statement ELSE statement
    (26) compound_stmt -> . IF ( condition ) statement
    (8) simple_stmt -> . PRINT print_list
    (9) simple_stmt -> . RETURN expr
    (10) simple_stmt -> . CONTINUE
    (11) simple_stmt -> . BREAK
    (12) simple_stmt -> . expr
    (13) simple_stmt -> . assignment
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (16) assignment -> . lvalue DIVASSIGN expr
    (17) assignment -> . lvalue MULASSIGN expr
    (18) assignment -> . lvalue SUBASSIGN expr
    (19) assignment -> . lvalue ADDASSIGN expr
    (20) assignment -> . lvalue = expr
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (14) lvalue -> . index
    (15) lvalue -> . ID
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (46) index -> . ID [ idx_list ]
    (61) matrix_literal -> . [ rows ]
    ;               shift and go to state 4
    {               shift and go to state 8
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 13
    PRINT           shift and go to state 14
    RETURN          shift and go to state 15
    CONTINUE        shift and go to state 17
    BREAK           shift and go to state 18
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    ID              shift and go to state 10
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    [               shift and go to state 34

    statement                      shift and go to state 131
    compound_block                 shift and go to state 5
    compound_stmt                  shift and go to state 6
    simple_stmt                    shift and go to state 7
    expr                           shift and go to state 16
    assignment                     shift and go to state 19
    term                           shift and go to state 20
    lvalue                         shift and go to state 22
    factor                         shift and go to state 24
    index                          shift and go to state 25
    matrix_literal                 shift and go to state 30

state 130

    (68) range_expr -> expr : expr : . expr
    (34) expr -> . term
    (35) expr -> . expr DOTSUB term
    (36) expr -> . expr DOTADD term
    (37) expr -> . expr MINUS term
    (38) expr -> . expr PLUS term
    (39) term -> . NEGATE term
    (40) term -> . MINUS term
    (41) term -> . factor
    (42) term -> . term DOTDIV factor
    (43) term -> . term DOTMUL factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term TIMES factor
    (47) factor -> . STRING
    (48) factor -> . SCINOTATION
    (49) factor -> . FLOATNUM
    (50) factor -> . INTNUM
    (51) factor -> . ( expr )
    (52) factor -> . matrix_literal
    (53) factor -> . ZEROS ( idx_list )
    (54) factor -> . EYE ( idx_list )
    (55) factor -> . ONES ( idx_list )
    (56) factor -> . factor '
    (57) factor -> . index
    (58) factor -> . ID
    (61) matrix_literal -> . [ rows ]
    (46) index -> . ID [ idx_list ]
    NEGATE          shift and go to state 23
    MINUS           shift and go to state 21
    STRING          shift and go to state 26
    SCINOTATION     shift and go to state 27
    FLOATNUM        shift and go to state 28
    INTNUM          shift and go to state 29
    (               shift and go to state 12
    ZEROS           shift and go to state 31
    EYE             shift and go to state 32
    ONES            shift and go to state 33
    ID              shift and go to state 43
    [               shift and go to state 34

    expr                           shift and go to state 132
    term                           shift and go to state 20
    factor                         shift and go to state 24
    matrix_literal                 shift and go to state 30
    index                          shift and go to state 42

state 131

    (25) compound_stmt -> IF ( condition ) statement ELSE statement .
    ;               reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    {               reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    FOR             reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    WHILE           reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    IF              reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    PRINT           reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    RETURN          reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    CONTINUE        reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    BREAK           reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    NEGATE          reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    MINUS           reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    ID              reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    STRING          reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    SCINOTATION     reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    FLOATNUM        reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    INTNUM          reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    (               reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    ZEROS           reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    EYE             reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    ONES            reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    [               reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    $end            reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    }               reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)
    ELSE            reduce using rule 25 (compound_stmt -> IF ( condition ) statement ELSE statement .)


state 132

    (68) range_expr -> expr : expr : expr .
    (35) expr -> expr . DOTSUB term
    (36) expr -> expr . DOTADD term
    (37) expr -> expr . MINUS term
    (38) expr -> expr . PLUS term
    ;               reduce using rule 68 (range_expr -> expr : expr : expr .)
    {               reduce using rule 68 (range_expr -> expr : expr : expr .)
    FOR             reduce using rule 68 (range_expr -> expr : expr : expr .)
    WHILE           reduce using rule 68 (range_expr -> expr : expr : expr .)
    IF              reduce using rule 68 (range_expr -> expr : expr : expr .)
    PRINT           reduce using rule 68 (range_expr -> expr : expr : expr .)
    RETURN          reduce using rule 68 (range_expr -> expr : expr : expr .)
    CONTINUE        reduce using rule 68 (range_expr -> expr : expr : expr .)
    BREAK           reduce using rule 68 (range_expr -> expr : expr : expr .)
    NEGATE          reduce using rule 68 (range_expr -> expr : expr : expr .)
    ID              reduce using rule 68 (range_expr -> expr : expr : expr .)
    STRING          reduce using rule 68 (range_expr -> expr : expr : expr .)
    SCINOTATION     reduce using rule 68 (range_expr -> expr : expr : expr .)
    FLOATNUM        reduce using rule 68 (range_expr -> expr : expr : expr .)
    INTNUM          reduce using rule 68 (range_expr -> expr : expr : expr .)
    (               reduce using rule 68 (range_expr -> expr : expr : expr .)
    ZEROS           reduce using rule 68 (range_expr -> expr : expr : expr .)
    EYE             reduce using rule 68 (range_expr -> expr : expr : expr .)
    ONES            reduce using rule 68 (range_expr -> expr : expr : expr .)
    [               reduce using rule 68 (range_expr -> expr : expr : expr .)
    DOTSUB          shift and go to state 48
    DOTADD          shift and go to state 49
    MINUS           shift and go to state 50
    PLUS            shift and go to state 51


Conflicts:

shift/reduce conflict for [ in state 43 resolved as shift